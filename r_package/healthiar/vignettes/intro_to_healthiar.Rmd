---
title: "intro_to_healthiar"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro_to_healthiar}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

------------------------------------------------------------------------

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(pacman)
pacman::p_load(healthiar, tibble, dplyr, purrr, tidyr, stringr, pillar, knitr)
options(knitr.kable.max_rows = 10)
set.seed(1)

```

Hi there!

This vignette will 1) tell you about `healthiar`, 2) help you install the `healthiar` package, and 3) show you how to use `healthiar` with the help of examples.

*NOTE*: By using healthiar you agree to the [terms of use](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#readme) and confirm you have read the [disclaimer](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#readme).

*NOTE*: the development of `healthiar` is still ongoing. Any feedback regarding bugs, unclear documentation, ... is welcome and highly appreciated. Please provide feedback via a [GitHub issue](https://github.com/best-cost/best-cost_WPs/issues).

------------------------------------------------------------------------

# How to install `healthiar`

## Initial installation

Prerequisite: access to the [BEST-COST GitHub repository](https://github.com/best-cost/best-cost_WPs) with your GitHub account. If you don't have access yet, write to [alberto.castrofernandez\@swisstph.ch](mailto:alberto.castrofernandez@swisstph.ch){.email} or [axel.luyten\@swisstph.ch](mailto:axel.luyten@swisstph.ch){.email} and provide them with the email address of the GitHub account they should give access to.

For initial installation follow the detailed steps in the [README](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#readme). The main steps are:

1.  Generate a GitHub personal access token (PAT)
2.  Use your PAT to connect RStudio with your GitHub profile
3.  Install the (newest version) of `healhtiar` by running code below

```{r setup, eval=FALSE, include=TRUE}
credentials::set_github_pat() # Paste GitHub PAT if prompted

devtools::install_github(
  repo = "best-cost/best-cost_WPs",
  subdir = "/r_package/healthiar",
  ref = "HEAD", # By default "HEAD"; branch name to install package from  
  force = TRUE,
  build_vignettes = TRUE
)

library(healthiar)
```

## Updating `healthiar`

After the initial installation we recommend to regularly update `healthiar` by running the code provided in step 3 above.

------------------------------------------------------------------------

# About `healthiar`

The main function family of `healthiar` is the attribute family, used to attribute health impacts to a risk factor, e.g. noise or air pollution. The core function `attribute_health` can be used for most (non-lifetable) assessments. For lifetable assessments the functions ending in `..._from_lifetable` are used.

![Figure: `healthiar` overview](images/EPHC_poster_landscape_v0.2.2_only_package_overview.jpg){width="700"}

------------------------------------------------------------------------

# How to use `healthiar`

\`healthiar\` comes with some example data that start with `exdat_` that allow you to test functions.

```{r, eval=TRUE, echo=FALSE, include=TRUE}
package_data <- data(package = "healthiar")[["results"]] |> 
  as_tibble() |> 
  select(Item) |> 
  filter(str_detect(Item, "exdat")) |> 
  mutate(Item = stringr::str_replace(Item, " \\(example_data\\)", "")) |> 
  rename(example_variables = Item) |> 
  # print()
  pull(example_variables) |>
  print()
  # cat(paste(collapse = "\n"), "\n")
```

## Example: attribute COPD cases to pop-weighted mean exposure

### Function call

We call the `attribute_health` with input data from the package example data. Note that we provide input data to the function argument using the `$` operator.

```{r Calculate prevalence, include=FALSE, eval=TRUE}
# Remove this chunk once the prevalence column is added to the example data
exdat_pm_copd <- exdat_pm_copd |> 
  mutate(prevalence = incidents_per_100_000_per_year/1E5*population_at_risk)
```

```{r, eval=TRUE, include=TRUE, echo=TRUE}
results_pm_copd <-
  healthiar::attribute_health(
    erf_shape = "log_linear",
    rr_central = exdat_pm_copd$relative_risk, 
    rr_lower = exdat_pm_copd$relative_risk_lower,
    rr_upper = exdat_pm_copd$relative_risk_upper,
    rr_increment = 10, 
    exp_central = exdat_pm_copd$mean_concentration,
    cutoff_central = exdat_pm_copd$cut_off_value,
    bhd_central = exdat_pm_copd$prevalence
)

```

### Results inspection

Every attribute output consists of two lists

-   `health_main` contains the main results

-   `health_detailed` detailed results (saved in the tibble `raw)` and (in some cases) even more information about the assessment/calculation

Let's inspect the main results

```{r, include=TRUE, eval=TRUE, echo=TRUE}
results_pm_copd[["health_main"]]

```

It is a tibble of 3 rows and 22 columns. Let's zoom in on some relevant aspects

```{r Alternative printing ways (NOT SHOWN), include=FALSE, eval=FALSE}
# options(pillar.bold = TRUE)
# getOption("pillar.bold")
options(tibble.print_min = Inf)
options(tibble.print_max = Inf)

results_pm_copd |> 
  pluck("health_main") |>
  select(exp, bhd, rr, erf_ci, pop_fraction, impact_rounded) |> 
  print()

results_pm_copd |> 
  pluck("health_main") |>
  select(exp, bhd, rr, erf_ci, pop_fraction, impact_rounded) |> 
  as.data.frame() |> 
  print()

```

```{r}
results_pm_copd |> 
  pluck("health_main") |>
  select(exp, bhd, rr, erf_ci, pop_fraction, impact_rounded) |> 
  knitr::kable() # Prints tibble in a minimal layout
```

Interpretation: this table shows us that exposure was 8.85 $\mu g/m^3$, the baseline health data (bhd) was 30747 (COPD cases in this instance). The 1st row further shows that the impact attributable to this exposure using the central relative risk (rr) estimate of 1.369 is 3502 COPD cases, or \~11% of all baseline cases.

The 2nd and 3rd rows show the impact using the lower and the upper estimates of the 95% confidence interval of the relative risk.

*NOTE*: the main output contains more columns that provide additional information about the assessment, such as cutoff, the relative risk at the observed exposure level, the shape of the ERF, ...

### Including uncertainty in several input parameters

Now we will make a similar function call, but include uncertainty in several input arguments.

```{r}

results_pm_copd <-
  healthiar::attribute_health(
    erf_shape = "log_linear",
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    rr_increment = 10, 
    exp_central = exdat_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff_central = exdat_pm_copd$cut_off_value, 
    bhd_central = exdat_pm_copd$prevalence,
    bhd_lower = exdat_pm_copd$prevalence - 5000,
    bhd_upper = exdat_pm_copd$prevalence + 5000
    )

```

Let's inspect the detailed results:

```{r}
results_pm_copd |> 
  purrr::pluck("health_detailed") |>
  purrr::pluck("raw") |> 
  dplyr::select(contains("_ci"), impact_rounded) |> 
  knitr::kable() # Prints tibble in a minimal layout
```

We see that each row represents a unique combination of the provided input variable estimates:

-   The 1st row shows the impact when using the central estimates of each input variable

-   The 2nd row shows the impact when using the central estimates of the relative risk, exposure in combination with the lower estimate of the baseline health

-   ...

(Note that only 9 of the 27 possible combinations are displayed due to space constraints.)

### Adding summary uncertainty

You can do a Monte Carlo uncertainty analysis via the `include_summary_uncertainty` function.

```{r}

results_pm_copd <- 
  include_summary_uncertainty(
    results = results_pm_copd,
    n_sim = 1000
)

```

The outcome of the Monte Carlo analysis is added to the variable entered as the `results` argument, which is `results_pm_copd` in our case.

Two folders are added:

-   `uncertainty_main` contains the central estimate and the corresponding 95% confidence intervals obtained through the Monte Carlo assessment

-   `uncertainty_detailed` contains all `n_sim` simulations of the Monte Carlo assessment

```{r summary uncertainty}

print(
  results_pm_copd |> 
  purrr::pluck("uncertainty_main")
  )

results_pm_copd |> 
  purrr::pluck("uncertainty_detailed") |> 
  purrr::pluck("raw") |> 
  select(rr:impact_total) |> 
  knitr::kable()

```

### Adding monetization of results

You can monetize the obtained health impacts via the `include_monetization` function.

```{r monetization}

results_pm_copd <- 
  include_monetization(
    output_healthiar = results_pm_copd,
    approach_discount = "direct",
    discount_shape = "exponential",
    discount_rate = 0.03,
    discount_years = 5,
    valuation = 50000, # E.g. EURO
    discount_overtime = "all_years"
  )


results_pm_copd |> 
  purrr::pluck("monetization_main") |> 
  select(erf_ci, impact, monetized_impact) |> 
  knitr::kable()
  
```

We see that the monetized impact (discounted) is more than 160 million EURO.

The outcome of the monetization is added to the variable entered to the `output_healthiar` argument, which is `results_pm_copd` in our case.

Two folders are added:

-   `monetization_main` contains the central estimate and the corresponding 95% confidence intervals obtained through the specified monetization

-   `monetization_detailed` contains the monetized results for each unique combination of the input variable estimates that were provided to the initial `attribute_health()` call

### Adding a cost-benefit analysis (CBA) using the results

Let's imagine we design a policy that would reduce air pollution to 5 $\mu g/m^3$, which is the concentration specified in the `cutoff_central` argument in the initial `attribute_health()` call. So we could avoid all COPD cases attributed to air pollution.

What would be the monetary benefit of such a policy, considering also the cost to implement the policy (estimated at 100 million EURO)? We can find out using `healthiar`'s `include_cba()` function.

```{r cba}

cba <- 
  healthiar::include_cba(
    output_healthiar = results_pm_copd,
    approach_discount = "direct",
    valuation = 50000,
    cost = 100000000,
    discount_shape = "exponential",
    discount_rate_benefit = 0.03,
    discount_rate_cost = 0.03,
    discount_years_benefit = 5,
    discount_years_cost = 5,
    discount_overtime = "all_years"
  )

cba |> 
  purrr::pluck("cba_main") |> 
  select(benefit, cost, benefit_minus_cost) |> 
  knitr::kable()

```

We see that the central and upper 95& confidence interval estimates of avoided attributable COPD cases result in a net monetary benefit of the policy, while the lower 95% confidence interval estimate results in a net cost!

The outcome of the CBA is contained in two folders are added:

-   `cba_main` contains the central estimate and the corresponding 95% confidence intervals obtained

-   `cba_detailed` contains additional intermediate results for both cost and benefit

## Example: attribute cases of high annoyance to (road) noise exposure

```{r}

exdat_noise_ha <-
  exdat_noise_ha |>
  dplyr::filter(!is.na(exdat_noise_ha$exposure_mean))

results_noise_ha <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = exdat_noise_ha$exposure_mean,
    population = sum(exdat_noise_ha$population_exposed_total), 
    prop_pop_exp = exdat_noise_ha$population_exposed_total / 
      sum(exdat_noise_ha$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2")
```

```{r echo=FALSE}
results_noise_ha |> 
  pluck("health_main") |>
  select(erf_eq, erf_ci, impact_rounded) |> 
  knitr::kable() # Prints tibble in a minimal layout
```

## Example: assess impact in multiple geographic units

To iterate an burden or impact assessment over multiple geo units the geo-specific information, such as the `exp_...` and `bhd_...` arguments, have to be entered as a list, i.e. wrapped by the `as.list` function. Additionally, specify the `geo_id_disaggregated` (e.g. "Brussels") and `geo_id_aggregated` (e.g. "Belgium") arguments that assign a IDs to the geo units

We use the `runif` function to simulate data for 5 Swiss cantons.

```{r}

results_iteration <- 
  healthiar::attribute_health(
    exp_central = as.list(runif(5, 8.0, 9.0)),
    exp_lower = as.list(runif(5, 8.0, 9.0) - 0.1),
    exp_upper = as.list(runif(5, 8.0, 9.0) + 0.1),
    cutoff_central = 5,   
    bhd_central = as.list(runif(5, 25000, 35000)),
    bhd_lower = as.list(runif(5, 25000, 35000) - 1000),
    bhd_upper = as.list(runif(5, 25000, 35000) + 1000),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_disaggregated = c("Zurich", "Basel", "Geneva", "Ticino", "Grisons"), 
    geo_id_aggregated = rep("CH", 5), # CH = abbreviation of Switzerland
  )



```
