---
title: "map_calculation_pathtways"
author: "Axel Luyten"
output: html_document
---

To limit the number of possible pathways there is one pathway per major calculation group:
- rr & ar
- lifetable
- social analysis
- monetization

```{r setup}

pacman::p_load(dplyr, tibble, stringr, purrr)

```


```{r RR pathways}

# * Define all relevant pathways ###############################################
## Create tibble containing (almost) all possible calculation pathways
pathways_rr <- list(
  erf = c("log_lin", "point_pairs", "formula", "lin_lin", "lin_log", "log_log"),
  exp = c("single", "dist"), # prop_pop_exp linked with this
  cutoff = c("TRUE", "FALSE"),
  varuncer = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  multiexp = c("FALSE", "additive", "multiplicative", "combined")
)

pathways_rr <- expand.grid(pathways_rr) |> 
  tibble::as_tibble() |>
  mutate_all(as.character) %>% # IMPORTANT TO USE magrittr PIPE
  ## Create all pathway ID's
  mutate(
    pathway_id = purrr::pmap_chr(., function(...) {
      vals <- list(...)
paste0("pathway_rr|", paste(names(vals), vals, sep = "_", collapse = "|"), "|")
})
  ) 

#* Define core pathways ########################################################
core_rr <- list(
  erf = c("log_lin", "point_pairs", "lin_lin"),
  exp = c("single", "dist"), # prop_pop_exp linked with this
  cutoff = c("TRUE", "FALSE"),
  varuncer = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  multiexp = c("FALSE")
)

core_rr <- expand.grid(core_rr) |> 
  tibble::as_tibble() |>
  mutate_all(as.character) |> 
  mutate(core_pathway = "TRUE")

pathways_rr <- pathways_rr |> 
  left_join(x = _, y = core_rr, by = c("erf", "exp", "cutoff", "varuncer", "iteration", "multiexp")) |> 
  mutate(core_pathway = ifelse(is.na(core_pathway), "FALSE", core_pathway)) |> 
  mutate(implemented = "FALSE")

# * Document existing pathways #################################################
file_path <- "../healthiar/tests/testthat/test-attribute_health.R"
file_content <- readLines(file_path) # String vector where each element is all code from a line

test_names <- regmatches(file_content, gregexpr('testthat::test_that\\("\\K[^"]+(?=", \\{)', file_content, perl = TRUE))
test_names_with_pw <- Filter(function(x) any(grepl("pathway_rr\\|", x)), test_names)
# test_names <- unlist(test_names)

## Create an empty tibble with NA placeholders
num_rows <- length(test_names_with_pw)
existing_tests <- tibble(
  erf = rep(NA_character_, num_rows),
  exp = rep(NA_character_, num_rows),
  cutoff = rep(NA_character_, num_rows),
  varuncer = rep(NA_character_, num_rows),
  iteration = rep(NA_character_, num_rows),
  multiexp = rep(NA_character_, num_rows),
  implemented = rep(FALSE, num_rows)
)

## Extract values and assign them directly to the tibble
for (i in seq_along(test_names_with_pw)) {
  strings <- test_names_with_pw[[i]] # Current list item

  # Extract values for each column
  existing_tests$exp[i] <- str_extract(strings[str_detect(strings, "\\|exp_")], "(?<=\\|exp_)[^\\|]+")
  existing_tests$cutoff[i] <- str_extract(strings[str_detect(strings, "\\|cutoff_")], "(?<=\\|cutoff_)[^\\|]+")
  existing_tests$varuncer[i] <- str_extract(strings[str_detect(strings, "\\|varuncer_")], "(?<=\\|varuncer_)[^\\|]+")
  existing_tests$erf[i] <- str_extract(strings[str_detect(strings, "\\|erf_")], "(?<=\\|erf_)[^\\|]+")
  existing_tests$iteration[i] <- str_extract(strings[str_detect(strings, "\\|iteration_")], "(?<=\\|iteration_)[^\\|]+")
  existing_tests$multiexp[i] <- str_extract(strings[str_detect(strings, "\\|multiexp_")], "(?<=\\|multiexp_)[^\\|)]+")
  existing_tests$implemented[i] <- "TRUE"
}

## Merge the pathways tibble and the existing_tests tibble
pathways_rr_implemented <- pathways_rr %>%
  left_join(existing_tests, by = c("erf", "exp", "cutoff", "varuncer", "iteration", "multiexp"),
            suffix = c("", ".existing")) %>%
  mutate(implemented = coalesce(implemented.existing, implemented)) %>%
  select(-implemented.existing)

## Check that nrow matches
if ( nrow(pathways_rr_implemented) == nrow(pathways_rr) ) {
  print("All good, rows match")
} else {
  print("WATCH OUT, ROWS DON'T MATCH")
  ## In case comparison is FALSE, find out which rows are duplicated
  extra_rows <- pathways_rr_implemented %>%
  anti_join(pathways_rr, by = c("erf", "exp", "cutoff", "iteration", "multiexp", "varuncer"))
  print(extra_rows)
}

## Output short report
total_rows <- nrow(pathways_rr_implemented)
true_implemented_rows <- pathways_rr_implemented %>%
  filter(implemented == "TRUE") %>%
  nrow()
cat("Number of pathways implemented as tests:", true_implemented_rows, "\n")
cat("Total possible number of pathways:", total_rows, "\n")
cat("As percentage:", round(true_implemented_rows/total_rows*100, digits = 0), "%\n")

```



```{r Pathways lifetable}
## Estimation of core cases
# ov_lifetable <- list(
#   exp = c("single", "dist"), # prop_pop_exp linked with this
#   exp_time = c("single_year", "constant"),
#   newborns = c("TRUE", "FALSE"),
#   # min_age = c("TRUE", "FALSE"),
#   # max_age = c("TRUE", "FALSE"),
#   # time_horizon = c("TRUE", "FALSE"),
#   iteration = c("TRUE", "FALSE"),
#   varuncer = c("TRUE", "FALSE")
# )

ov_lifetable <- list(
  exp = c("single", "dist"), # prop_pop_exp linked with this
  exp_time = c("single_year", "constant"),
  newborns = c("TRUE", "FALSE"),
  min_age = c("TRUE", "FALSE"),
  max_age = c("TRUE", "FALSE"),
  time_horizon = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  varuncer = c("TRUE", "FALSE")
)

pathways_lifetable <- expand.grid(ov_lifetable)

pathways_lifetable <- pathways_lifetable |> 
  as_tibble() |> 
  dplyr::mutate(test_name = "NULL") |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable daly single exposure and one year exposure without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "single" & exp_time == "single_year" & newborns == "TRUE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable premature deaths single year exposure with newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "dist" & exp_time == "constant" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable premature deaths exposure distribution with constant exposure and without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yld single exposure and one year exposure without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll single exposure and one year exposure and without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "single" & exp_time == "constant" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll single exposure and constant exposure and without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "single" & exp_time == "constant" & newborns == "TRUE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll single exposure and constant exposure and with newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "dist" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll exposure distribution and one year exposure and without newborns", TRUE ~ test_name))
```

```{r Pathways summary uncertainty}

## Estimation number of core cases
# ov_uncertainty <- list(
#   exp = c("single", "dist"),
#   erf = c("rr_increment", "rr_formula", "rr_point_pairs", "ar_formula", "ar_point_pairs"),
#   iteration = c("TRUE", "FALSE")
# )

ov_uncertainty <- list(
  exp = c("single", "dist"),
  erf = c("rr_increment", "rr_formula", "rr_point_pairs", "ar_formula", "ar_point_pairs"),
  iteration = c("TRUE", "FALSE"),
  distribution = c("normal", "beta", "other")
)

pathways_uncertainty <- expand.grid(ov_uncertainty)

pathways_uncertainty <- pathways_uncertainty |> 
  as_tibble() |> 
  dplyr::mutate(test_name = "NULL")
```

Both the functions include_cba and include_discount call the 
function include_monetization in the background --> created only ov_monetization 
instead of creating an overview tibble for all 3 functions
```{r Pathways monetization}

## Estimation number of core cases
# ov_monetization <- list(
#   discount_appr = c("direct", "indirect"), # direct is the default
#   discount_rate = c("TRUE", "FALSE"),
#   discount_shape = c("exp", "hyp_harvey", "hyp_mazur"),
#   discount_overtime = c("all_years", "last_year") # all_years is default
# )

ov_monetization <- list(
  discount_appr = c("direct", "indirect"), # direct is the default
  discount_rate = c("TRUE", "FALSE"),
  discount_shape = c("exp", "hyp_harvey", "hyp_mazur"),
  discount_overtime = c("all_years", "last_year") # all_years is default
)

pathways_monetization <- expand.grid(ov_monetization)

pathways_monetization <- pathways_monetization |> 
  as_tibble() |> 
  dplyr::mutate(test_name = "NULL") |> 
  dplyr::mutate(test_name = case_when(
    ( discount_appr == "direct" & discount_rate == "FALSE" & discount_shape == "FALSE" & discount_overtime == "all_years" ) ~
      "results correct simple monetization", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( discount_appr == "direct" & discount_rate == "TRUE" & discount_shape == "exp" & discount_overtime == "last_year" ) ~
      "results correct direct discounting with discount factor and exponential discount shape", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( discount_appr == "indirect" & discount_rate == "TRUE" & discount_shape == "exp" & discount_overtime == "all_years" ) ~
      "results correct indirect discounting with exponential discount shape", TRUE ~ test_name))  
  
```

```{r Pathways non-lifetable compare}

## Estimation number of core cases
# ov_rr_compare <- list(
#   comp_appr = c("delta", "pif")
# )

ov_rr_compare <- list(
  comp_appr = c("delta", "pif"),
  erf = c("lin_lin", "log_lin", "lin_log", "log_log", "formula", "point_pairs"), # all options
  # erf = c("log_lin", "lin_lin", "formula", "point_pairs"), # more relevant options
  exp = c("single", "dist"), # prop_pop_exp linked with this
  cutoff = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  multiexp = c("FALSE", "additive", "multiplicative", "combined"),
  varuncer = c("TRUE", "FALSE")
)

pathways_rr_compare <- expand.grid(ov_rr_compare)

pathways_rr_compare <- pathways_rr_compare |> 
  tibble::as_tibble() |> 
  dplyr::mutate(test_name = "NULL")

pathways_rr_compare <- pathways_rr_compare |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "log_lin" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "log_lin" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "TRUE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison iteration rr single exposures", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "pif" &
      erf == "log_lin" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct pif comparison rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "pif" &
      erf == "log_lin" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "iteration" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct pif comparison iteration rr single exposures", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "formula" & 
      exp == "dist" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison ar exposure distribution", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "formula" & 
      exp == "dist" & 
      cutoff == "TRUE" & 
      iteration == "TRUE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison rr single exposure", TRUE ~ test_name)) 
```



```{r Pathways lifetable compare}

## Estimation number of core cases
# ov_lifetable_compare <- list(
#   comp_appr = c("delta", "pif")
# )

ov_lifetable_compare <- list(
  comp_appr = c("delta", "pif"),
  exp = c("single", "dist"), # prop_pop_exp linked with this
  exp_time = c("single_year", "constant"),
  newborns = c("TRUE", "FALSE"),
  min_age = c("TRUE", "FALSE"),
  max_age = c("TRUE", "FALSE"),
  time_horizon = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  varuncer = c("TRUE", "FALSE")
)

pathways_lifetable_compare <- expand.grid(ov_lifetable_compare)

pathways_lifetable_compare <- pathways_lifetable_compare |> 
  tibble::as_tibble() |> 
  dplyr::mutate(test_name = "NULL")

pathways_lifetable_compare <- pathways_lifetable_compare |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "delta" & exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE" & varuncer == "FALSE") ~
      "results correct delta comparison lifetable daly rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "delta" & exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "TRUE" & varuncer == "FALSE") ~
      "results correct delta comparison lifetable daly iteration rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "pif " & exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE" & varuncer == "FALSE") ~
      "results correct pif comparison lifetable daly rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "pif " & exp == "single" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE" & varuncer == "FALSE") ~
      "results correct pif comparison lifetable daly iteration rr single exposure", TRUE ~ test_name))
  
  
```




```{r Example, eval=FALSE, include=FALSE}
library(DiagrammeR) ; library(data.tree)
knitr::opts_knit$set(root.dir = getwd()) 

steps <- list(
  ERF_shape = c("linear", "log-linear"),
  cutoff = c(0, 5),
  exposure_metric = c("mean", "median", "P95"),
  population_subgroup = c("all", "adults", "children")
)

## Get all possible combinations: each row is a unique pathway
pathways <- expand.grid(steps)

pathways <- pathways |> 
  dplyr::mutate(pathway_id = seq_len(nrow(pathways)))

DiagrammeR::grViz("
  digraph pathways {
    rankdir=LR;
    node [shape = rectangle];
    A [label = 'ERF Shape'];
    B [label = 'Cutoff'];
    C [label = 'Exposure Metric'];
    D [label = 'Population Subgroup'];

    A -> B -> C -> D;
  }
")

## Build tree with {data.tree}
create_tree <- function(steps, current_node) {
  step_name <- names(steps)[1]  # Get the current step name
  options <- steps[[1]]        # Get the options for the current step
  remaining_steps <- steps[-1] # Remove the current step from the list
  
  for (option in options) {
    child <- current_node$AddChild(option)  # Add child node for each option
    if (length(remaining_steps) > 0) {
      create_tree(remaining_steps, child)  # Recursive call for remaining steps
    }
  }
}
root <- Node$new("Start")
create_tree(steps, root)
print(root, "level")
plot(root)

```
```{r Test extraction of single test name}
# Read the file content
file_path <- "../healthiar/tests/testthat/test-attribute_health.R"
file_content <- readLines(file_path) # String vector where each element is all code from a line

# Extract all test names
test_names <- regmatches(file_content, gregexpr('testthat::test_that\\("\\K[^"]+(?=", \\{)', file_content, perl = TRUE))

# Flatten the list into a single vector
test_names <- unlist(test_names)

# Define the string
name_string <- test_names[2]
print(test_names[2])

# Use a regex to extract the parts that contain "pw_"
pw_id_raw <- str_extract_all(name_string, "pw_[^ ]+")[[1]]

# Remove "pw_" prefix and store in the character vector pw_id
pw_id_raw <- str_remove(pw_id_raw, "^pw_")
print(pw_id_raw)

# Remove prefix and _
pw_id <- str_replace(pw_id_raw, "^[^_]+_", "")

# Select row & mark as implemented
test_pw <- pathways_rr |> 
  dplyr::mutate(test_name = case_when(
    ( erf == pw_id[1] & 
      exp == pw_id[2] & 
      cutoff == pw_id[3] & 
      iteration == pw_id[4] & 
      multiexp == pw_id[5] & 
      varuncer == pw_id[6]) 
    ~ name_string, TRUE ~ test_name))

```

```{r test extraction of all relevant test names}

file_path <- "../healthiar/tests/testthat/test-attribute_health.R"
file_content <- readLines(file_path) # String vector where each element is all code from a line

test_names <- regmatches(file_content, gregexpr('testthat::test_that\\("\\K[^"]+(?=", \\{)', file_content, perl = TRUE))
test_names_with_pw <- Filter(function(x) any(grepl("pathway\\|", x)), test_names)
# test_names <- unlist(test_names)


## Create an empty tibble with NA placeholders
num_rows <- length(test_names_with_pw)
existing_tests <- tibble(
  erf = rep(NA_character_, num_rows),
  exp = rep(NA_character_, num_rows),
  cutoff = rep(NA_character_, num_rows),
  varuncer = rep(NA_character_, num_rows),
  iteration = rep(NA_character_, num_rows),
  multiexp = rep(NA_character_, num_rows),
  implemented = rep(FALSE, num_rows)
)

## Extract values and assign them directly to the tibble
for (i in seq_along(test_names_with_pw)) {
  strings <- test_names_with_pw[[i]] # Current list item

  # Extract values for each column
  existing_tests$exp[i] <- str_extract(strings[str_detect(strings, "\\|exp_")], "(?<=\\|exp_)[^\\|]+")
  existing_tests$cutoff[i] <- str_extract(strings[str_detect(strings, "\\|cutoff_")], "(?<=\\|cutoff_)[^\\|]+")
  existing_tests$varuncer[i] <- str_extract(strings[str_detect(strings, "\\|varuncer_")], "(?<=\\|varuncer_)[^\\|]+")
  existing_tests$erf[i] <- str_extract(strings[str_detect(strings, "\\|erf_")], "(?<=\\|erf_)[^\\|]+")
  existing_tests$iteration[i] <- str_extract(strings[str_detect(strings, "\\|iteration_")], "(?<=\\|iteration_)[^\\|]+")
  existing_tests$multiexp[i] <- str_extract(strings[str_detect(strings, "\\|multiexp_")], "(?<=\\|multiexp_)[^\\|)]+")
  existing_tests$implemented[i] <- "TRUE"
}

## Mark the column "implemented" in tibble of all pathways with "TRUE" if the test exists
result <- pathways_rr %>%
  left_join(existing_tests, by = c("erf", "exp", "cutoff", "varuncer", "iteration", "multiexp"),
            suffix = c("", ".existing")) %>%
  mutate(implemented = coalesce(implemented.existing, implemented)) %>%
  select(-implemented.existing)

# ## Check that nrow matches
# nrow(result) == nrow(pathways_rr_ar)
# ## In case comparison is FALSE, find out which rows are duplicated
# extra_rows <- result %>%
#   anti_join(pathways_rr_ar, by = c("erf", "exp", "cutoff", "iteration", "multiexp", "varuncer"))

```

```{r OLD Pathways non-lifetable}
ov_rr_ar <- list(
  erf = c("lin_lin", "log_lin", "lin_log", "log_log", "formula", "point_pairs"),
  # erf = c("log_lin", "lin_lin", "formula", "point_pairs"),
  exp = c("single", "dist"), # prop_pop_exp linked with this
  cutoff = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  multiexp = c("FALSE", "additive", "multiplicative", "combined"),
  varuncer = c("TRUE", "FALSE")
)

pathways_rr_ar <- expand.grid(ov_rr_ar)

pathways_rr_ar <- pathways_rr_ar |> 
  tibble::as_tibble() |>
  mutate_all(as.character) |> 
  mutate(implemented = FALSE)
  
  # dplyr::mutate(test_name = "NULL")

pathways_rr_ar <- pathways_rr_ar |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "result correct rr with single exposure value and only rr_central", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "result correct rr with single exposure and variable uncertainty", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun with cutoff of 5", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "single" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & with cutoff of 5", TRUE ~ test_name))  |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "single" & 
      cutoff == "FALSE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & with cutoff of 5", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "dist" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & no cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "dist" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & with cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "dist" & 
      cutoff == "TRUE" & 
      iteration == "TRUE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct rr iteration with exposure distribution and uncertainties in rr and exp", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "dist" & 
      cutoff == "FALSE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct rr exposure distribution", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "formula" & 
      exp == "dist" & 
      cutoff == "FALSE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct ar without cutoff", TRUE ~ test_name)) |> 
  ## FIX EXAMPLE IN TEST SCRIPT ####
  # dplyr::mutate(test_name = case_when(
  #   ( erf == "formula" & 
  #     exp == "dist" & 
  #     cutoff == "FALSE" & 
  #     iteration == "FALSE" & 
  #     multiexp == "FALSE" & 
  #     varuncer == "FALSE") 
  #   ~ "results correct ar with cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "formula" & exp == "dist" & cutoff == "FALSE" & iteration == "TRUE" &  multiexp == "FALSE" & varuncer == "FALSE" ) ~
      "results correct ar iteration no variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "formula" & exp == "dist" & cutoff == "FALSE" & iteration == "FALSE" &  multiexp == "FALSE" & varuncer == "TRUE" ) ~
      "results correct ar iteration with variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "single" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "additive" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure additive approach no variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "single" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "additive" & varuncer == "TRUE" ) ~
      "detailed results correct rr multiple exposure additive approach with variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "single" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "multiplicative" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure multiplicative approach", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "single" & cutoff == "FALSE" & iteration == "FALSE" &  multiexp == "multiplicative" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure multiplicative approach without cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "single" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "combined" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure combined approach", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "single" & cutoff == "FALSE" & iteration == "FALSE" &  multiexp == "combined" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure combined approach without cutoff", TRUE ~ test_name))

```
