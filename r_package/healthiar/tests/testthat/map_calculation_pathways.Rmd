---
title: "map_calculation_pathtways"
author: "Axel Luyten"
output: html_document
---

To limit the number of possible pathways there is one pathway per major calculation group:
- rr & ar
- lifetable
- social analysis
- monetization

```{r setup}

pacman::p_load(dplyr, tibble, stringr)

```

```{r Test extraction of test names}
# Read the file content
file_path <- "../healthiar/tests/testthat/test-attribute_health.R"
file_content <- readLines(file_path)

# Extract all test names
test_names <- regmatches(file_content, gregexpr('testthat::test_that\\("\\K[^"]+(?=", \\{)', file_content, perl = TRUE))

# Flatten the list into a single vector
test_names <- unlist(test_names)

# Print the extracted test names
# print(test_names)

test <- test_names[2]
print(test)

# Define the string
input_string <- test_names[2]

# Use a regex to extract the parts that contain "pw_"
matches <- str_extract_all(input_string, "pw_[^ ]+")[[1]]

# Remove "pw_" prefix and store in the character vector pw_id
pw_id <- str_remove(matches, "^pw_")

# Print the result
print(pw_id)

# Remove prefix and _
pw_id <- str_replace(pw_id, "^[^_]+_", "")

# Select row
test_pw <- pathways_rr_ar |> 
  dplyr::mutate(test_name = case_when(
    ( erf == pw_id[1] & 
      exp == pw_id[2] & 
      cutoff == pw_id[3] & 
      iteration == pw_id[4] & 
      multiexp == pw_id[5] & 
      varuncer == pw_id[6]) 
    ~ "TRUE", TRUE ~ test_name))


```

```{r Pathways non-lifetable}
ov_rr_ar <- list(
  # erf = c("lin_lin", "log_lin", "lin_log", "log_log", "formula", "point_pairs"),
  erf = c("log_lin", "lin_lin", "formula", "point_pairs"),
  exp = c("pop_weighted", "exp_dist"), # prop_pop_exp linked with this
  cutoff = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  multiexp = c("FALSE", "additive", "multiplicative", "combined"),
  varuncer = c("TRUE", "FALSE")
)

pathways_rr_ar <- expand.grid(ov_rr_ar)

pathways_rr_ar <- pathways_rr_ar |> 
  tibble::as_tibble() |> 
  dplyr::mutate(test_name = "NULL")

pathways_rr_ar <- pathways_rr_ar |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "result correct rr with single exposure value and only rr_central", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "result correct rr with single exposure and variable uncertainty", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun with cutoff of 5", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & with cutoff of 5", TRUE ~ test_name))  |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "pop_weighted" & 
      cutoff == "FALSE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & with cutoff of 5", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "exp_dist" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & no cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "point_pairs" & 
      exp == "exp_dist" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct user-defined erf (mrbrt) with splinefun and uncertainties erf & with cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "exp_dist" & 
      cutoff == "TRUE" & 
      iteration == "TRUE" & 
      multiexp == "FALSE" & 
      varuncer == "TRUE") 
    ~ "results correct rr iteration with exposure distribution and uncertainties in rr and exp", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & 
      exp == "exp_dist" & 
      cutoff == "FALSE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct rr exposure distribution", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "formula" & 
      exp == "exp_dist" & 
      cutoff == "FALSE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct ar without cutoff", TRUE ~ test_name)) |> 
  ## FIX EXAMPLE IN TEST SCRIPT ####
  # dplyr::mutate(test_name = case_when(
  #   ( erf == "formula" & 
  #     exp == "exp_dist" & 
  #     cutoff == "FALSE" & 
  #     iteration == "FALSE" & 
  #     multiexp == "FALSE" & 
  #     varuncer == "FALSE") 
  #   ~ "results correct ar with cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "formula" & exp == "exp_dist" & cutoff == "FALSE" & iteration == "TRUE" &  multiexp == "FALSE" & varuncer == "FALSE" ) ~
      "results correct ar iteration no variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "formula" & exp == "exp_dist" & cutoff == "FALSE" & iteration == "FALSE" &  multiexp == "FALSE" & varuncer == "TRUE" ) ~
      "results correct ar iteration with variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "pop_weighted" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "additive" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure additive approach no variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "pop_weighted" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "additive" & varuncer == "TRUE" ) ~
      "detailed results correct rr multiple exposure additive approach with variable uncertainties", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "pop_weighted" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "multiplicative" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure multiplicative approach", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "pop_weighted" & cutoff == "FALSE" & iteration == "FALSE" &  multiexp == "multiplicative" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure multiplicative approach without cutoff", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "pop_weighted" & cutoff == "TRUE" & iteration == "FALSE" &  multiexp == "combined" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure combined approach", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( erf == "log_lin" & exp == "pop_weighted" & cutoff == "FALSE" & iteration == "FALSE" &  multiexp == "combined" & varuncer == "FALSE" ) ~
      "results correct rr multiple exposure combined approach without cutoff", TRUE ~ test_name))
  
  


```


```{r Pathways lifetable}

ov_lifetable <- list(
  exp = c("pop_weighted", "exp_dist"), # prop_pop_exp linked with this
  exp_time = c("single_year", "constant"),
  newborns = c("TRUE", "FALSE"),
  min_age = c("TRUE", "FALSE"),
  max_age = c("TRUE", "FALSE"),
  time_horizon = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  varuncer = c("TRUE", "FALSE")
)

pathways_lifetable <- expand.grid(ov_lifetable)

pathways_lifetable <- pathways_lifetable |> 
  as_tibble() |> 
  dplyr::mutate(test_name = "NULL") |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable daly single exposure and one year exposure without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "pop_weighted" & exp_time == "single_year" & newborns == "TRUE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable premature deaths single year exposure with newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "exp_dist" & exp_time == "constant" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable premature deaths exposure distribution with constant exposure and without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yld single exposure and one year exposure without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll single exposure and one year exposure and without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "pop_weighted" & exp_time == "constant" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll single exposure and constant exposure and without newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "pop_weighted" & exp_time == "constant" & newborns == "TRUE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll single exposure and constant exposure and with newborns", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( exp == "exp_dist" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE"& varuncer == "FALSE") ~
      "results correct lifetable yll exposure distribution and one year exposure and without newborns", TRUE ~ test_name))

```

```{r Pathways summary uncertainty}

ov_uncertainty <- list(
  exp = c("pop_weighted", "exp_dist"),
  erf = c("rr_increment", "rr_formula", "rr_point_pairs", "ar_formula", "ar_point_pairs"),
  iteration = c("TRUE", "FALSE")
)

pathways_uncertainty <- expand.grid(ov_uncertainty)

pathways_uncertainty <- pathways_uncertainty |> 
  as_tibble() |> 

  dplyr::mutate(test_name = "NULL")
```

Both the functions include_cba and include_discount call the 
function include_monetization in the background --> created only ov_monetization 
instead of creating an overview tibble for all 3 functions
```{r Pathways monetization}

ov_monetization <- list(
  discount_appr = c("direct", "indirect"), # direct is the default
  discount_rate = c("TRUE", "FALSE"),
  discount_shape = c("exp", "hyp_harvey", "hyp_mazur"),
  discount_overtime = c("all_years", "last_year") # all_years is default
)

pathways_monetization <- expand.grid(ov_monetization)

pathways_monetization <- pathways_monetization |> 
  as_tibble() |> 
  dplyr::mutate(test_name = "NULL") |> 
  dplyr::mutate(test_name = case_when(
    ( discount_appr == "direct" & discount_rate == "FALSE" & discount_shape == "FALSE" & discount_overtime == "all_years" ) ~
      "results correct simple monetization", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( discount_appr == "direct" & discount_rate == "TRUE" & discount_shape == "exp" & discount_overtime == "last_year" ) ~
      "results correct direct discounting with discount factor and exponential discount shape", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( discount_appr == "indirect" & discount_rate == "TRUE" & discount_shape == "exp" & discount_overtime == "all_years" ) ~
      "results correct indirect discounting with exponential discount shape", TRUE ~ test_name))  
  
```

```{r Pathways non-lifetable compare}

ov_rr_ar_compare <- list(
  comp_appr = c("delta", "pif"),
  # erf = c("lin_lin", "log_lin", "lin_log", "log_log", "formula", "point_pairs"), # all options
  erf = c("log_lin", "lin_lin", "formula", "point_pairs"), # more relevant options
  exp = c("pop_weighted", "exp_dist"), # prop_pop_exp linked with this
  cutoff = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  multiexp = c("FALSE", "additive", "multiplicative", "combined"),
  varuncer = c("TRUE", "FALSE")
)

pathways_rr_ar_compare <- expand.grid(ov_rr_ar_compare)

pathways_rr_ar_compare <- pathways_rr_ar_compare |> 
  tibble::as_tibble() |> 
  dplyr::mutate(test_name = "NULL")

pathways_rr_ar_compare <- pathways_rr_ar_compare |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "log_lin" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "log_lin" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "TRUE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison iteration rr single exposures", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "pif" &
      erf == "log_lin" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct pif comparison rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "pif" &
      erf == "log_lin" & 
      exp == "pop_weighted" & 
      cutoff == "TRUE" & 
      iteration == "iteration" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct pif comparison iteration rr single exposures", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "formula" & 
      exp == "exp_dist" & 
      cutoff == "TRUE" & 
      iteration == "FALSE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison ar exposure distribution", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr = "delta" &
      erf == "formula" & 
      exp == "exp_dist" & 
      cutoff == "TRUE" & 
      iteration == "TRUE" & 
      multiexp == "FALSE" & 
      varuncer == "FALSE") 
    ~ "results correct delta comparison rr single exposure", TRUE ~ test_name)) 
```



```{r Pathways lifetable compare}

ov_lifetable_compare <- list(
  comp_appr = c("delta", "pif"),
  exp = c("pop_weighted", "exp_dist"), # prop_pop_exp linked with this
  exp_time = c("single_year", "constant"),
  newborns = c("TRUE", "FALSE"),
  min_age = c("TRUE", "FALSE"),
  max_age = c("TRUE", "FALSE"),
  time_horizon = c("TRUE", "FALSE"),
  iteration = c("TRUE", "FALSE"),
  varuncer = c("TRUE", "FALSE")
)

pathways_lifetable_compare <- expand.grid(ov_lifetable_compare)

pathways_lifetable_compare <- pathways_lifetable_compare |> 
  tibble::as_tibble() |> 
  dplyr::mutate(test_name = "NULL")

pathways_lifetable_compare <- pathways_lifetable_compare |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "delta" & exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE" & varuncer == "FALSE") ~
      "results correct delta comparison lifetable daly rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "delta" & exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "TRUE" & varuncer == "FALSE") ~
      "results correct delta comparison lifetable daly iteration rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "pif " & exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE" & varuncer == "FALSE") ~
      "results correct pif comparison lifetable daly rr single exposure", TRUE ~ test_name)) |> 
  dplyr::mutate(test_name = case_when(
    ( comp_appr == "pif " & exp == "pop_weighted" & exp_time == "single_year" & newborns == "FALSE" & min_age == "TRUE" &  max_age == "FALSE" & time_horizon == "FALSE" & iteration == "FALSE" & varuncer == "FALSE") ~
      "results correct pif comparison lifetable daly iteration rr single exposure", TRUE ~ test_name))
  
  
```




```{r Example, eval=FALSE, include=FALSE}
library(DiagrammeR) ; library(data.tree)
knitr::opts_knit$set(root.dir = getwd()) 

steps <- list(
  ERF_shape = c("linear", "log-linear"),
  cutoff = c(0, 5),
  exposure_metric = c("mean", "median", "P95"),
  population_subgroup = c("all", "adults", "children")
)

## Get all possible combinations: each row is a unique pathway
pathways <- expand.grid(steps)

pathways <- pathways |> 
  dplyr::mutate(pathway_id = seq_len(nrow(pathways)))

DiagrammeR::grViz("
  digraph pathways {
    rankdir=LR;
    node [shape = rectangle];
    A [label = 'ERF Shape'];
    B [label = 'Cutoff'];
    C [label = 'Exposure Metric'];
    D [label = 'Population Subgroup'];

    A -> B -> C -> D;
  }
")

## Build tree with {data.tree}
create_tree <- function(steps, current_node) {
  step_name <- names(steps)[1]  # Get the current step name
  options <- steps[[1]]        # Get the options for the current step
  remaining_steps <- steps[-1] # Remove the current step from the list
  
  for (option in options) {
    child <- current_node$AddChild(option)  # Add child node for each option
    if (length(remaining_steps) > 0) {
      create_tree(remaining_steps, child)  # Recursive call for remaining steps
    }
  }
}
root <- Node$new("Start")
create_tree(steps, root)
print(root, "level")
plot(root)
```

