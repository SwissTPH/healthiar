---
title: "Calculate mortality long"
author: "Axel Luyten"
date: "`r Sys.Date()`"
output: pdf_document
---

Calculate the mortality impacts of one crf_id ("PM2.5_premature deaths_all causes_adults_main_Hoek_2013_sensitivity") step by step to identify potential bottlenecks.

Places to check are marked with # NOTE: ...

```{r load data}
load("testing/input/performance/PER assess_mortality_lifetable() data.Rdata")

library(tidyverse) ; library(profvis) ; library(bestcost)
```

```{r define input data}
#impact_mortality_raw <- list()

exp = input_data_mortality$exp[2] # PM2.5=8.30=limit LRV CH, NO2=16.32=mean conc. in CH in 2019
cf = input_data_mortality$cf[2]   # PM2.5=5, NO2=10, i.e. WHO AQG 2021
crf = unlist(input_data_mortality[2, c("crf_mean", "crf_lowci", "crf_highci")])
crf_per = 10
crf_rescale_method = "loglinear"
lifetable_withPop_male = lifetable_withPopulation[["male"]]
lifetable_withPop_female = lifetable_withPopulation[["female"]]
firstYear_lifetable = 2019
nonNatural_death_male = mortality_data[["male"]] # % of non-natural male deaths in BHD
nonNatural_death_female = mortality_data[["female"]] # % of non-natural female deaths in BHD
pollutant = input_data_mortality$pollutant[2]
age_group = input_data_mortality$outcome_group[2]
min_age = 20
max_age = 0
corrected_discount_rate = 0
exp_info = NULL
cf_info = NULL
crf_info =NULL
```

# assess_mortality_lifetable()
This code happens in "assess_mortality_lifetable.R"
```{r digest input data}

input_fun <- list()

        if(is.null(exp_info)){
          input_fun[["exp"]] <- data.frame(exp = exp)
        } else {
          # When there is an extra_info data frame
          # the values from argument should replace the values
          # of likely columns with same name
          input_fun[["exp"]] <- exp_info
          input_fun[["exp"]]$exp <- exp}

        if(is.null(cf_info)){
          input_fun[["cf"]] <- data.frame(cf = cf)
        } else {
          input_fun[["cf"]] <- cf_info
          input_fun[["cf"]]$cf <- cf}

        if(is.null(crf_info)){
          input_fun[["crf"]] <- data.frame(crf = crf)
        } else {
          input_fun[["crf"]] <- crf_info
          input_fun[["crf"]]$crf <- crf
          input_fun[["crf"]]$crf_per <- crf_per}

        # Add ci
        input_fun[["crf"]] <-
          mutate(input_fun[["crf"]],
                 ci = ifelse(crf %in% min(crf), "lowci",
                        ifelse(crf %in% max(crf), "highci",
                               "mean")))

        # Add pollutant to all input data tables to provide a common key for joining
        # {{}} ensure that the value from the function argument is used
        # instead of from an existing column is used
        input_fun <-
          input_fun %>%
          purrr::map(~mutate(.,
                             pollutant = {{pollutant}},
                             outcome_group = {{age_group}}))

        # The life table has to be provided as a data.frame (by sex)
        # The first column has to be the age. Second, probability of death. Third, population.
        # Rename column names to standard names
        names(lifetable_withPop_male) <-
          c("age", "death_probability", paste0("population_", firstYear_lifetable))
        names(lifetable_withPop_female) <-
          c("age", "death_probability", paste0("population_", firstYear_lifetable))
        # Store data in a list
        lifetable_withPop <- list(male = lifetable_withPop_male,
                                  female = lifetable_withPop_female)


        # The mortality has to be provided as a data.frame (by sex)
        # The first column has to be the age. Second, percent_nonNatural.
        # Rename column names to standard names
        names(nonNatural_death_male) <-
          c("age", "percent_nonNatural")
        names(nonNatural_death_female) <-
          c("age", "percent_nonNatural")
        # Store data in a list
        nonNatural_death <- list(male = nonNatural_death_male,
                                 female = nonNatural_death_female)
        
        # shifted_popOverTime <-
        #   bestcost::get_pop_impact(
            lifetab_withPop <- lifetable_withPop # NOTE: variable name slightly different
            nonNatural_death <- nonNatural_death
            # firstYear_lifetable = firstYear_lifetable # NOTE: same as initial input
            crf <- input_fun[["crf"]]
            # crf_per = crf_per # NOTE: same as initial input
            # age_group = age_group # NOTE: same as initial input
            exp <- input_fun[["exp"]] # NOTE: existing variable "exp" is overwritten
            cf <- input_fun[["cf"]] # NOTE: existing variable "cf" is overwritten
            # crf_rescale_method = crf_rescale_method # NOTE: same as initial input
            # )
```

# get_pop_impact()
```{r}
popOverTime <- list()
```

```{r calling get_popOverTime())}
sex <-  c("male", "female") # can be removed once added to function code
ci <- c("mean", "lowci", "highci") # can be removed once added to function code

profvis(for(s in sex){
      for(v in ci){
        popOverTime[[s]][[v]] <-
          bestcost::get_popOverTime( # AL: replaced healthiar with bestcost
            lifetab_withPop = lifetable_withPop[[s]],
            nonNatural_death = nonNatural_death[[s]],
            firstYear_lifetable = firstYear_lifetable,
            crf = crf$crf[crf$ci %in% v],
            exp = exp,
            cf = cf,
            crf_per = crf_per,
            crf_rescale_method = crf_rescale_method,
            age_group = age_group)
      }
}
)
```

```{r }
shifted_popOverTime <- list()
```

```{r calling shifted_popOverTime()}
for(s in sex){
      for(v in ci){
        shifted_popOverTime[[s]][[v]] <-
          bestcost::move_rows_up(popOTime = popOverTime[[s]][[v]][["diff"]], # AL: replaced healthiar with bestcost ####
                                        firstYear_lifetable = firstYear_lifetable)
      }
    }
```

```{r}
output <-
      list(crf = crf,
           popOverTime = popOverTime,
           shifted_popOverTime = shifted_popOverTime)


    # return(output)
```

# assess_mortality_lifetable()
```{r calling get_deaths()}
shifted_popOverTime <- output # added so that this Rmd runs


profvis(deaths <- bestcost::get_deaths(shifted_popOverTime = shifted_popOverTime,
                                       firstYear_lifetable = firstYear_lifetable,
                                       age_group = age_group,
                                       min_age = min_age,
                                       max_age = max_age,
                                       exp = input_fun[["exp"]] ,
                                       cf = input_fun[["cf"]],
                                       crf_rescale_method = crf_rescale_method))#,
        # rerun = TRUE)
```

```{r calling get_yll()}
profvis(yll <-
          bestcost::get_yll_new( #AL: changed from bestcost::get_yll( and the results are exactly the same
            shifted_popOverTime = shifted_popOverTime,
            firstYear_lifetable = firstYear_lifetable,  # NOTE: same as initial input
            age_group = age_group, # NOTE: same as initial input
            min_age = min_age, # NOTE: same as initial input
            max_age = max_age, # NOTE: same as initial input
            exp = input_fun[["exp"]] ,
            cf = input_fun[["cf"]],
            crf_rescale_method = crf_rescale_method, # NOTE: same as initial input
            corrected_discount_rate = corrected_discount_rate) # NOTE: same as initial input
)
```

```{r compiling output}
output <-
          list(
            shifted_popOverTime = shifted_popOverTime,
            deaths_long = deaths[["deaths_long"]],
            deaths = deaths[["deaths"]],
            yll_long = yll[["yll_long"]],
            yll = yll[["yll"]])
```
# Output is the same as when running assess_mortality_lifetable() directly






# Performance assessment
In the code of get_popOverTime_noAP(), the data frame "lifetable_withPop[["female"]] is grown in a loop
```{r evaluate single call of get_popOverTime_noAP}
# Check output 
output <- bestcost::get_popOverTime_noAP(
  lifetable_wPop = lifetable_withPop[["female"]],
  firstYear_lifetable = firstYear_lifetable,
  year_loopStart = firstYear_lifetable + 1
  )


profvis(bestcost::get_popOverTime_noAP(
  lifetable_wPop = lifetable_withPop[["female"]],
  firstYear_lifetable = firstYear_lifetable,
  year_loopStart = firstYear_lifetable + 1
  )
)
```

In the code of this optimized function the data frame (tibble) to be used in the loop is defined in advance.
```{r evaluate single call of get_popOverTime_noAP_opt}
profvis(bestcost::get_popOverTime_noAP_opt(
  lifetable_wPop = lifetable_withPop[["female"]],
  firstYear_lifetable = firstYear_lifetable,
  year_loopStart = firstYear_lifetable + 1
  )
)
```




