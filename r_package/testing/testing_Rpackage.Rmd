---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---
# Goal
Test the functions of the bestcost package comparing the results with results from other tools or assessments


# Load packages and data


The R script required the loading of certain R packages. 
```{r Load packages, include=FALSE}
# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(zoo)

# to set colors in console messages (checking)
library(crayon)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)

# Load bestcost package (either current version or installed version)
devtools::load_all(export_all = FALSE)
```



```{r Alternative 1 to load bestcost: Install own package from github, eval=FALSE, include=FALSE}
# Install own package from github as suggested here: https://stackoverflow.com/a/71846333/6104907
if(!"bestcost" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT if prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/bestcost",
                           ref = "HEAD", # Branch name (by default "HEAD") as a string
                           force = TRUE)
}
library(bestcost)
```



```{r Alternative 2 to load bestcost: load zip from local source, eval=FALSE, include=FALSE}
detach("package:bestcost", unload = TRUE) # detach bestcost
devtools::build(binary = TRUE, path = "../testing/input/") # Save current state of package as .zip file (e.g. to directly test changes in functions)
install.packages("../testing/input/bestcost_0.0.0.1.zip", repos=NULL, type='source') # Install package from source
library(bestcost)
```


Load the Rdata file that contains all variables needed to run this script.
```{r load data, include=FALSE}
load("../testing/input/data/input_data_for_testing_Rpackage.RData")

prob_dying <- list()
for(d in c("natural", "total")){
  for(s in c("male", "female")){
   prob_dying[[d]][[s]] <-
     bestcost::get_prob_dying_by_single_age(
      first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      interval_age_pop = 
        unique(airqplus_pm_deaths_yll[["pop"]]$age_from... - 
                 airqplus_pm_deaths_yll[["pop"]]$age_from...) + 1,
      population_midyear = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("midyear_population_", s)]),
      deaths = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("number_of_deaths_", s)]))
  }
}

# Load (summed) YLL data from AirQ+ output Excel no newborns
airqplus_yll_total_per_year_no_newborns <- tibble(year = 2019:2118,
                                                  impact = unname(as_vector(read_excel("../testing/output/airqplus_deaths_yll_lifetable_adults.xlsx", 
                                                                                       range = "B109:CW109", 
                                                                                       sheet = "yll_difference", 
                                                                                       col_names = FALSE))))

# Load (summed) YLL data from AirQ+ output Excel with newborns
airqplus_yll_total_per_year_with_newborns <- tibble(year = 2019:2118,
                                                  impact = unname(as_vector(read_excel("../testing/output/airqplus_deaths_yll_lifetable_adults.xlsx", 
                                                                                       range = "B103:CW103", 
                                                                                       sheet = "yll_difference", 
                                                                                       col_names = FALSE))))

# Load premature death data 2019 from AirQ+ output Excel
airqplus_premature_deaths_2019 <- tibble(age = 0:99,
                                         impact = unname(as_vector(read_excel("../testing/output/airqplus_deaths_yll_lifetable_adults.xlsx", 
                                                                              range = "B1:B101", 
                                                                              sheet = "deaths_difference", 
                                                                              col_names = TRUE))))

# Load YLL data 
airqplus_yll_difference <- read.xlsx("../testing/output/airqplus_deaths_yll_lifetable_adults.xlsx", sheet = "yll_difference", startRow = 1, rows = c(1:101))
```



# Calculate health impacts

## Attributable health impact

### Single baseline health data

```{r single exposure value}
# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central,
                estimated_number_of_attributable_cases_lower,
                estimated_number_of_attributable_cases_upper)%>%
  unlist()


check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```


```{r multiple single exposure value, eval=FALSE, include=FALSE}
# Assess attributable cases for multiple uncertainties at the same time
# i.e. rr, bhd and exp
bestcost_pm_copd_multiple <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = 25000,
    bhd_upper = 35000,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))


# Assess iteration geographical sections keeping the multiple uncertainties
system.time(bestcost_pm_copd_geo <-
  bestcost::attribute_health(
    exp_central = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    cutoff = 5,   
    bhd_central = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info = "PM2.5_copd"))

```


```{r single exposure value and relative risk}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd_1rr <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_1rr_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central)%>%
  unlist()


check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)


```


```{r exposure distribution}

# Extract rows that contain input data (others may contain results)
niph_noise_ihd_input <- 
  niph_noise_ihd_excel %>%
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ihd_result <- 
  niph_noise_ihd_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(daly)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  bestcost::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))


check_bestcost(result_list_bestcost = bestcost_noise_ihd_expDist,
               result_vector_alternative = niph_noise_ihd_result)

# Obtain attributable cases using the bestcost package
# for multiple geo_sections
bestcost_noise_ihd_expDist_geo <- 
  bestcost::attribute_health(
    exp_central = list(runif_with_seed(5,8,10,1), 
                       runif_with_seed(5,8,10,2), 
                       runif_with_seed(5,8,10,3)),
    cutoff = 5,
    prop_pop_exp = list(runif_with_seed(5,0.1,1,1),
                        runif_with_seed(5,0.1,1,2), 
                        runif_with_seed(5,0.1,1,3)),
    bhd_central = list(runif_with_seed(3,1E4,1E5,1)),
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    geo_id_raw = 1:3,
    geo_id_aggregated = rep("ch", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r absolute risk}

# Extract rows that contain input data (others may contain results)
niph_noise_ha_input <- 
  niph_noise_ha_excel %>%
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ha_result <- 
  niph_noise_ha_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(number)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ha_ar <- 
  bestcost::attribute_health_ar(
    exp_central = niph_noise_ha_input$exposure_mean,
    pop_exp = niph_noise_ha_input$population_exposed_total, 
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result)


# Obtain attributable cases using the bestcost package and input data from niph
# for multiple geo_sections
bestcost_noise_ha_ar_geo <- 
  bestcost::attribute_health_ar(
    exp_central = list(runif_with_seed(5,8,10,1), 
                          runif_with_seed(5,8,10,2), 
                          runif_with_seed(5,8,10,3)),
    pop_exp = list(runif_with_seed(5,5E3,1E4,1), 
                   runif_with_seed(5,5E3,1E4,2), 
                   runif_with_seed(5,5E3,1E4,3)), 
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_raw = 1:3,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r morbidity yld with single relative risk}

bestcost_pm_yld_singlebhd  <- 
  bestcost::attribute_yld_from_prevalence(
    exp_central = 8.85, 
    cutoff = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd ,
               result_vector_alternative = c(525, 277, 768)) # Result on 16 May 2024


```


### Life table

#### Probability of dying

```{r Probability of dying}

# Remove years over 40 
# because we are going to compare with results up to 39 years old
airqplus_prob_dying_age0to39_multipleYear <- 
  airqplus_deaths_pop_multipleYear%>%
  dplyr::filter(To<40)

# Results from the AirQ+ manual (to be compared with bestcost results)
airqplus_prob_dying_age0to39_singleYear <-
  airqplus_deaths_pop_singleYear%>%
  dplyr::filter(To<40)%>%
  dplyr::mutate(qx = as.numeric(qx))

# Use bestcost function
bestcost_prob_dying <- 
  bestcost::get_prob_dying_by_single_age(
    first_age_pop = first(airqplus_prob_dying_age0to39_multipleYear$From),
    last_age_pop = last(airqplus_prob_dying_age0to39_multipleYear$To),
    interval_age_pop = first(airqplus_prob_dying_age0to39_multipleYear$To) - first(airqplus_prob_dying_age0to39_multipleYear$From)+1,
    population_midyear = airqplus_prob_dying_age0to39_multipleYear$mi,
    deaths = airqplus_prob_dying_age0to39_multipleYear$di,
    fraction_of_year_lived = 0.5
  )


# Compare and show message with colors

if(all((bestcost_prob_dying$prob_dying - 
        airqplus_prob_dying_age0to39_singleYear$qx) < 0.002)){
  cat(paste(crayon::yellow("Bestcost and alternative source with similar results.")))
} else{
    cat(paste(crayon::red("Attention! Check! Bestcost and alternative source with very different results.")))}
# There is a very small deviation 
# due to different rounding 
# (bestcost does not round, while airqplus does)
```


#### Premature deaths

```{r premature deaths with lifetable airqplus input}

# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case

bestcost_pm_deaths_lifetable_airqplus <-
  bestcost::attribute_deaths_from_lifetable(
    approach_exposure = "single_year",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)


# check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus,
#                result_vector_alternative = c(2600.9, 1371, 3804))

if ( abs(bestcost_pm_deaths_lifetable_airqplus[["main"]][["impact_rounded"]][[1]] - 2601 ) / 2601 * 100 < 0.001  ) {
  cat(paste0("best-cost: ", round(bestcost_pm_deaths_lifetable_airqplus[["main"]][["impact_rounded"]][[1]]),"\n",
             "AirQ+: ", 2601,"\n"),
      crayon::cyan("Right. Bestcost and alternative with almost identical results (< 0.001%)."))
} else {
    cat(paste0("best-cost: ", round(bestcost_pm_deaths_lifetable_airqplus[["main"]][["impact_rounded"]][[1]]),"\n",
             "AirQ+: ", 2601,"\n"),
        crayon::red("Attention! Check! Bestcost and alternative with different results (> 0.001%)."))}
```



```{r premature deaths with lifetable and exposure distribution}

# Calculate premature deaths using bestcost function
bestcost_pm_deaths_lifetable_expDistribution <- 
    bestcost::attribute_deaths_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
      rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
      rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
      rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = 20)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_expDistribution, # bestcost_pm_deaths_lifetable_geluft, 
               result_vector_alternative = c(2610, 1378, 3815)) # Result on 16 May 2024
```
It is to be expected that the best-cost results are higher (11.11%) than the alternative
source results: the exposure from the exposure distributions (best-cost) is a bit 
higher than the single value exposure (alternative source).



#### Years of life lost

```{r YLL from SINGLE YEAR EXPOSURE}

# Now with input data from the Swiss project GeLuft
bestcost_pm_yll_exposure_single_year_lifetable_airqplus <-
  bestcost::attribute_yll_from_lifetable(
    approach_exposure = "single_year",
    exp_central = input_data_mortality$exp[2], #exp CH 2019
    prop_pop_exp = 1,
    cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_exposure_single_year_lifetable_airqplus,
                result_vector_alternative = c(27742, 14641, 40542)) # GeLuft results; difference to bestcost results should be 3.86%
               # result_vector_alternative = airqplus_pm_deaths_yll)
              
# View(bestcost_pm_yll_exposure_single_year_lifetable_airqplus)
```
Difference (between best-cost and GeLuft results) should be 3.86%.

```{r YLL from CONSTANT EXPOSURE and NO NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus <-
  bestcost::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "without_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus,
#                 result_vector_alternative = c(27742, 14641, 40542))

# Compare sex-specific results
# yll_male <- bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["lifeyears_nest"]][[1]] %>%
#   filter(year == 2019) %>%  select(impact) %>%  as_vector() %>%  unname(.)
# yll_female <- bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["lifeyears_nest"]][[2]] %>%
#   filter(year == 2019) %>% select(impact) %>% as_vector() %>%  unname(.)
# print("YLL male 2019 identical:") ; round(yll_male) == round(624.43) # Value from AirQ+ output Excel
# print("YLL female 2019 identical:") ; round(yll_female) == round(675.25) # Value from AirQ+ output Excel

# Compare total (= both sexes) YLL
yll_total_rounded <- round(bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["pop_impact_nest"]][[3]] %>% select(-age_end))
yll_total_unrounded <- bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["pop_impact_nest"]][[3]] %>% select(-age_end)

# Difference in total yearly YLLs
yll_total_comp <- tibble(year = airqplus_yll_total_per_year_no_newborns$year,
       airqplus_yll_total = airqplus_yll_total_per_year_no_newborns$impact,
       bestcost_yll_total_rounded = round(bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["lifeyears_nest"]][[3]]$impact))

yll_total_sum <- tibble(airqplus_yll_sum = sum(yll_total_comp$airqplus_yll_total),
                             bestcost_yll_sum = sum(yll_total_comp$bestcost_yll_total_rounded),
                             diff_abs = abs(airqplus_yll_sum - bestcost_yll_sum),
                             diff_percent = diff_abs / airqplus_yll_sum * 100)

if (yll_total_sum$diff_percent < 0.001) {
  cat(paste0("best-cost: ", yll_total_sum$bestcost_yll_sum,"\n",
             "AirQ+: ", yll_total_sum$airqplus_yll_sum,"\n"),
      crayon::cyan("Right. Bestcost and alternative with almost identical results (< 0.001%)."))
} else {
    cat(paste0("best-cost: ", yll_total_sum$bestcost_yll_sum,"\n",
             "AirQ+: ", yll_total_sum$airqplus_yll_sum,"\n"),
        crayon::red("Attention! Check! Bestcost and alternative with different results (> 0.001%)."))}

# # 2019
# print("2019 sum total YLLs (unrouded) identical:") # Value from AirQ+ output Excel
# 1300.43 == round(sum(bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["pop_impact_nest"]][[3]]$population_2019), digits = 2)
# print("2019 total YLLs identical:")
# table(airqplus_yll_difference$`2019` == yll_total_rounded$population_2019)
# table(airqplus_yll_difference$`2019` == yll_total_rounded$population_2019)
# print("2019 absolute difference in YLLs:")
# print(abs(airqplus_yll_difference$`2019`[1:100] - yll_total_rounded$population_2019[1:100]))
# 
# # 2020
# print("2020 sum total YLLs (unrouded) identical:") # Value from AirQ+ output Excel
# 3741.43 == round(sum(bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["pop_impact_nest"]][[3]]$population_2020, na.rm = TRUE), digits = 2)
# print("2020 total YLLs identical:")
# table(airqplus_yll_difference$`2020` == yll_total_rounded$population_2020)
# print("2020 absolute difference in YLLs:")
# print(abs(airqplus_yll_difference$`2020`[2:100] - yll_total_rounded$population_2020[2:100]))
# 
# 2021
# print("2021 absolute difference in total YLLs:")
# abs(6085 - round(sum(yll_total_rounded$population_2021, na.rm = TRUE), digits = 2)) # Value from AirQ+ output Excel
# print("2021 absolute difference in YLLs:")
# print(abs(airqplus_yll_difference$`2021` - yll_total_rounded$population_2021))
# 
# # 2050
# print("2050 absolute difference in total YLLs:")
# abs(41044 - round(sum(yll_total_rounded$population_2050, na.rm = TRUE), digits = 2)) # Value from AirQ+ output Excel
# print("2050 absolute difference in age-specific YLLs")
# print(abs(airqplus_yll_difference$`2050`[32:100] - yll_total_rounded$population_2050[32:100]))
# # Max difference constant at 1 --> rounding error
# 
# # 2100
# print("2100 absolute difference in total YLLs:")
# abs(20535 - round(sum(yll_total_rounded$population_2100, na.rm = TRUE), digits = 2)) # Value from AirQ+ output Excel
# print("2100 absolute difference in YLLs:")
# print(abs(airqplus_yll_difference$`2100`[82:100] - yll_total_rounded$population_2100[82:100]))
```
AirQ+ value is from the large AirQ+ output excel.

```{r YLL from CONSTANT EXPOSURE and WITH NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus_with_newborns <-
  bestcost::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# Compare total (= both sexes) YLL
yll_total_rounded <- round(bestcost_pm_yll_lifetable_airqplus_with_newborns[["detailed"]][["interim"]][["pop_impact_nest"]][[3]] %>% select(-age_end))
yll_total_unrounded <- bestcost_pm_yll_lifetable_airqplus_with_newborns[["detailed"]][["interim"]][["pop_impact_nest"]][[3]] %>% select(-age_end)

# Difference in total yearly YLLs
yll_total_comp <- tibble(year = airqplus_yll_total_per_year_with_newborns$year,
       airqplus_yll_total = airqplus_yll_total_per_year_with_newborns$impact,
       bestcost_yll_total_rounded = round(bestcost_pm_yll_lifetable_airqplus_with_newborns[["detailed"]][["interim"]][["lifeyears_nest"]][[3]]$impact))

yll_total_sum <- tibble(airqplus_yll_sum = sum(yll_total_comp$airqplus_yll_total),
                             bestcost_yll_sum = sum(yll_total_comp$bestcost_yll_total_rounded),
                             diff_abs = abs(airqplus_yll_sum - bestcost_yll_sum),
                             diff_percent = diff_abs / airqplus_yll_sum * 100)

if (yll_total_sum$diff_percent < 0.001) {
  cat(paste0("best-cost: ", yll_total_sum$bestcost_yll_sum,"\n",
             "AirQ+: ", yll_total_sum$airqplus_yll_sum,"\n"),
      crayon::cyan("Right. Bestcost and alternative with almost identical results (< 0.001%)."))
} else {
    cat(paste0("best-cost: ", yll_total_sum$bestcost_yll_sum,"\n",
             "AirQ+: ", yll_total_sum$airqplus_yll_sum,"\n"),
        crayon::red("Attention! Check! Bestcost and alternative with different results (> 0.001%)."))}
```
AirQ+ value is from the large AirQ+ output excel.

```{r yll lifetable with single relative risk}
# Only one relative risk estimate (central estimate)

# Calculate years of life lost using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yll_lifetable_1rr_geluft <- 
    bestcost::attribute_yll_from_lifetable(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff = input_data_mortality$cutoff[2], 
      rr_central = input_data_mortality[2,"rr_central"], 
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_1rr_geluft,
               result_vector_alternative = c(27742)) # GeLuft result
```
Difference to bestcost results should be 3.86% (difference bestcost and GeLuft results).

```{r yll lifetable with exposure distribution}

# Calculate years of life lost using bestcost function
# with exposure distribution (instead of population-weighted mean)

bestcost_pm_yll_lifetable_expDistribution_geluft <- 
    bestcost::attribute_yll_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      erf_increment = 10,
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_expDistribution_geluft ,
               result_vector_alternative = c(30931, 16337, 45166)) # Result on 16 May 2024

```
Difference should be 3.86%

#### Years lived with disability

```{r morbidity yld lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yld_lifetable_geluft  <- 
  attribute_yld_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    # exp_central = c(8, 9, 10), # Fake data. Deactivate to test exposure distribution.
    prop_pop_exp = 1,
    # prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data. Deactivate to test exposure distribution.
    cutoff = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper = input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure = "single_year",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration = 100, 
    dw_central = 1, dw_lower = 0.1, dw_upper = 10
  )

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
check_bestcost(result_list_bestcost = bestcost_pm_yld_lifetable_geluft,
               result_vector_alternative = c(27742, 14641, 40542)) # GeLuft results

```
Difference GeLuft to bestcost results should be 3.86%



#### Disability-adjusted lived years (DALY)

```{r morbidity daly lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_daly_lifetable_geluft  <- 
  attribute_daly_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    prop_pop_exp = 1,
    cutoff = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration = 100, 
    dw_central = 1
  )

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
# Since DALY = YLL + YLD and in this case YLL=YLD --> DALY = 2*YLL
check_bestcost(result_list_bestcost = bestcost_pm_daly_lifetable_geluft,
               result_vector_alternative = c(27742*2, 14641*2, 40542*2))

```
Difference GeLuft to bestcost results should be 3.86%

## Comparison

### Single bhd

```{r comparison singlebhd_rr}
# Test delta comparison function with fake values
# DELTA

comparison_singlebhd_rr_delta <-
  bestcost::compare_health(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta ,
               result_vector_alternative = c(774, 409, 1127)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_delta_geo <-
  bestcost::compare_health(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(1100, 582, 1603)) # Result on 26 June 2024

#PIF
# Test pif comparison function with fake values
comparison_singlebhd_rr_pif <-
  bestcost::compare(
    approach_comparison = "pif",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif ,
               result_vector_alternative = c(782, 412, 1146)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_pif_geo <-
  bestcost::compare_health(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(1114, 586, 1634)) # Result on 19 June 2024
```


```{r comparison singlebhd_rr geo iteration, eval=FALSE, include=FALSE}
# Assess iteration in many geographical areas (geo_id) keeping the multiple uncertainties
comparison_singlebhd_rr_geo <-
  bestcost::compare_health(
    approach_comparison = "delta",
    exp_central_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    exp_central_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)),
    exp_lower_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)-0.1),
    exp_upper_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)+0.1),
    cutoff = 5,   
    bhd_central_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_central_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")
```


```{r comparison ar}

# Test delta comparison function with fake values
# No PIF option in ar
comparison_singlebhd_ar_delta <-
  bestcost::compare_health_ar(
    approach_comparison = "delta",
    exp_central_1 = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    exp_central_2 = c(50, 55, 60, 65, 75), # Fake values
    pop_exp_1 = c(387500, 286000, 191800, 72200, 7700), # Values as example provided by NIPH
    pop_exp_2 = c(387500, 286000, 191800, 72200, 7700), # Fake values
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta ,
               result_vector_alternative = c(62531)) # Result on 23 May 2024

comparison_singlebhd_ar_delta_geo <-
  bestcost::compare_health_ar(
    approach_comparison = "delta",
    exp_central_1 = list(c(57.5, 62.5, 67.5, 72.5, 77.5), c(57, 62, 67, 72, 77)),# Fake values
    exp_central_2 = list(c(50, 55, 60, 65, 75), c(50.5, 55.5, 60.5, 65.5, 75.5)), # Fake values
    pop_exp_1 = list(c(387500, 286000, 191800, 72200, 7700), c(380000, 280000, 190800, 72000, 7000)), # Fake values
    pop_exp_2 = list(c(387500, 286000, 191800, 72200, 7700), c(380000, 280000, 190800, 72000, 7000)), # Fake values
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022),
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))


check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta_geo ,
               result_vector_alternative = 115869) # Result on 19 June 2024

```

```{r comparison yld singlebhd_rr}
# DELTA
# Test delta comparison function with fake values
comparison_yld_singlebhd_rr_delta <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta ,
               result_vector_alternative = c(387, 205, 564)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["main"]]$impact_rounded) 


# Iteration
comparison_yld_singlebhd_rr_delta_geo <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(591, 313, 861)) # Result on 26 June 2024


#PIF
# Test pif comparison function with fake values
comparison_yld_singlebhd_rr_pif <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "pif",
    exp_central_1 = 8.85,  
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")



# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif ,
               result_vector_alternative = c(391,206,573)) # Result on 16 May 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["main"]]$impact_rounded) 


# Iteration
comparison_yld_singlebhd_rr_pif_geo <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(599, 315, 878)) # Result on 20 June 2024


```

### Lifetable
```{r comparison deaths lifetable}

# DELTA

comparison_deaths_lifetable_delta <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta ,
               result_vector_alternative = c(1922,1017,2801)) # Result on 16 May 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta[["detailed"]][["scenario_1"]] ,
               # result_vector_alternative = bestcost_pm_deaths_lifetable_geluft[["main"]]$impact_rounded) # old GeLuft vector
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact_rounded)  

# Iteration
comparison_deaths_lifetable_delta_geo <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2= airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta_geo ,
               result_vector_alternative = c(2935, 1553, 4279)) # Result on 09 July 2024

# Additionally check that it produces the first scenario produce the same results as above
# comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.) == bestcost_pm_deaths_lifetable_geluft[["main"]]$impact 
comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.) == bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact
# Absolute differences
abs(comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.) 
    - bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact)
# Absolute differences are negligeable (< 0.01, or < 0.0001%)
      

# PIF

comparison_deaths_lifetable_pif  <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    approach_exposure_1 = "single_year",
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    approach_exposure_2 = "single_year",
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    min_age = 20)



# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif ,
               result_vector_alternative = c(1943,1023,2847)) # Result on 16 May 2024

# Additionally check that scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif[["detailed"]][["scenario_1"]],
               # result_vector_alternative = bestcost_pm_deaths_lifetable_geluft[["main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact_rounded) 


# Iteration
comparison_deaths_lifetable_pif_geo <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif_geo ,
               result_vector_alternative = c(2974, 1563, 4362)) # Result on 09 July 2024


```

```{r Illustration integrate compare() in attribute()}

# Benefit of this: compare the two conceptionally different approaches
 
# case1 <- attribute(approach= cutoff in exposure)

# case2 <- attribute(approach = delta approach/cutoff in ERF)

# difference impact <- case1[[impact]] - case2[[impact]]
```



```{r comparison yll lifetable}

# DELTA 
comparison_yll_lifetable_delta  <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "constant",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019,
    approach_exposure_2 = "constant",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta ,
               result_vector_alternative = c(20421,10806,29763)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta[["detailed"]][["scenario_1"]] ,
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_lifetable_airqplus[["main"]]$impact_rounded)


# Iteration
comparison_yll_lifetable_delta_geo <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta_geo ,
               result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024

# PIF
comparison_yll_lifetable_pif <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "constant",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "constant",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20)


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               result_vector_alternative = c(20650,10870,30257)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif[["detailed"]][["scenario_1"]],
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_lifetable_airqplus[["main"]]$impact_rounded)


# Iteration
comparison_yll_lifetable_pif_geo <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif_geo ,
               result_vector_alternative = c(31601, 16613, 46359)) # Result on 08 July 2024

```





```{r comparison yld lifetable}

# DELTA
 
comparison_yld_lifetable_delta  <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta ,
               result_vector_alternative = c(20421,10806,29763)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["main"]]$impact_rounded) 



# Iteration
comparison_yld_lifetable_delta_geo <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta_geo ,
               result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024


# PIF
comparison_yld_lifetable_pif <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif ,
               result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["main"]]$impact_rounded)




# Iteration
comparison_yld_lifetable_pif_geo <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif_geo ,
               result_vector_alternative = c(31601, 16613, 46359)) # Result on 26 June 2024

```


```{r comparison daly lifetable}

# DELTA
 
comparison_daly_lifetable_delta  <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5, # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta ,
               result_vector_alternative = c(20421*2,10806*2,29763*2)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["main"]]$impact_rounded) 



# Iteration
comparison_daly_lifetable_delta_geo <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta_geo ,
               result_vector_alternative = c(31190*2, 16500*2, 45472*2)) # Result on 08 July 2024


# PIF
comparison_daly_lifetable_pif <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif ,
               result_vector_alternative = c(20650*2, 10870*2, 30257*2)) # Result on 16 May 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["main"]]$impact_rounded)




# Iteration
comparison_daly_lifetable_pif_geo <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif_geo ,
               result_vector_alternative = c(31601*2, 16613*2, 46359*2)) # Result on 26 June 2024

```

# Export 

```{r eval=FALSE, include=FALSE}
# write.csv2(lifetable_airqplus,
#             "../testing/output/lifetable_airqplus_2019_ch.csv", 
#             row.names = FALSE)
```
