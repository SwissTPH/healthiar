---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---
# Goal
Test the functions of the bestcost package comparing the results with results from other tools or assessments


# Load packages and data


The R script required the loading of certain R packages. 
```{r Load packages and data, include=FALSE}

# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(zoo)
library(stats)

# to set colors in console messages (checking)
library(crayon)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)

# Load bestcost package (either current version or installed version)
devtools::load_all(export_all = FALSE)

# Load data
load("../testing/input/data/input_data_for_testing_Rpackage.RData")
```



```{r Alternative 1 to load bestcost: Install own package from github, eval=FALSE, include=FALSE}
# Install own package from github as suggested here: https://stackoverflow.com/a/71846333/6104907
if(!"bestcost" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT if prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/bestcost",
                           ref = "HEAD", # Branch name (by default "HEAD") as a string
                           force = TRUE)
}
library(bestcost)
```



```{r Alternative 2 to load bestcost: load zip from local source, eval=FALSE, include=FALSE}
detach("package:bestcost", unload = TRUE) # detach bestcost
devtools::build(binary = TRUE, path = "../testing/input/") # Save current state of package as .zip file (e.g. to directly test changes in functions)
install.packages("../testing/input/bestcost_0.0.0.1.zip", repos=NULL, type='source') # Install package from source
library(bestcost)
```

# Calculate health impacts

## Attributable health impact

### Single baseline health data

```{r single exposure value}
# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    valuation = 1000,
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central,
                estimated_number_of_attributable_cases_lower,
                estimated_number_of_attributable_cases_upper)%>%
  unlist()

# View(bestcost_pm_copd)

check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```



```{r multiple single exposure value, eval=FALSE, include=FALSE}
# Assess attributable cases for multiple uncertainties at the same time
# i.e. rr, bhd and exp
bestcost_pm_copd_multiple <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = 25000,
    bhd_upper = 35000,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    valuation = 1000,
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))


# Assess iteration geographical sections keeping the multiple uncertainties
system.time(bestcost_pm_copd_geo <-
  bestcost::attribute_health(
    exp_central = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    cutoff = 5,   
    bhd_central = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info = "PM2.5_copd"))

```


```{r single exposure value and user-defined points for relative risk}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_alri_erf_dots <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    # GBD2019 ERF for PM and lower respiratory infections
    erf_eq_central = 
      stats::splinefun(
        x = c(600,500,400,300,200,150,130,110,90,70,50,30,25,20,15,10,5,0),
        y = c(2.189,2.143,2.098,2.052,1.909,1.751,1.68,1.607,1.533,1.453,1.357,1.238,1.204,1.168,1.129,1.089,1.046,	1),
        method = "natural"),
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))


#TODO: Make an automatic comparison to always check if the result is right
```


```{r single exposure value and relative risk with monetization}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd_1rr <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    valuation = 1000,
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_1rr_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central)%>%
  unlist()

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```


```{r exposure distribution}

# Extract rows that contain input data (others may contain results)
niph_noise_ihd_input <- 
  niph_noise_ihd_excel %>%
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ihd_result <- 
  niph_noise_ihd_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(daly)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  bestcost::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    valuation = 1000,
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))


#View(bestcost_noise_ihd_expDist)
check_bestcost(result_list_bestcost = bestcost_noise_ihd_expDist,
               result_vector_alternative = niph_noise_ihd_result)

 
# Obtain attributable cases using the bestcost package
# for multiple geo_sections
bestcost_noise_ihd_expDist_geo <- 
  bestcost::attribute_health(
    exp_central = list(runif_with_seed(5,8,10,1), 
                       runif_with_seed(5,8,10,2), 
                       runif_with_seed(5,8,10,3)),
    cutoff = 5,
    prop_pop_exp = list(runif_with_seed(5,0.1,1,1),
                        runif_with_seed(5,0.1,1,2), 
                        runif_with_seed(5,0.1,1,3)),
    bhd_central = list(runif_with_seed(3,1E4,1E5,1)),
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    geo_id_raw = 1:3,
    geo_id_aggregated = rep("ch", 3),
    valuation = 1000,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r absolute risk}

# Extract rows that contain input data (others may contain results)
niph_noise_ha_input <- 
  niph_noise_ha_excel %>%
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ha_result <- 
  niph_noise_ha_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(number)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ha_ar <- 
  bestcost::attribute_health_ar(
    exp_central = niph_noise_ha_input$exposure_mean,
    pop_exp = niph_noise_ha_input$population_exposed_total, 
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    valuation = 1000,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

# View(bestcost_noise_ha_ar)

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result)


# Obtain attributable cases using the bestcost package and input data from niph
# for multiple geo_sections
bestcost_noise_ha_ar_geo <- 
  bestcost::attribute_health_ar(
    exp_central = list(runif_with_seed(5,8,10,1), 
                          runif_with_seed(5,8,10,2), 
                          runif_with_seed(5,8,10,3)),
    pop_exp = list(runif_with_seed(5,5E3,1E4,1), 
                   runif_with_seed(5,5E3,1E4,2), 
                   runif_with_seed(5,5E3,1E4,3)), 
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_raw = 1:3,
    valuation = 1000,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r YLD with single relative risk}

bestcost_pm_yld_singlebhd  <- 
  bestcost::attribute_yld_from_prevalence(
    exp_central = 8.85, 
    cutoff = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    valuation = 1000,
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10)

# View(bestcost_pm_yld_singlebhd)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd ,
               result_vector_alternative = c(525, 277, 768)) # Result on 16 May 2024

# Summary uncertainty
bestcost_pm_yld_ci <- get_ci(paf = bestcost_pm_yld_singlebhd$main$pop_fraction[1], # PAF central estimate
                             bhd_central = bestcost_pm_yld_singlebhd$main$bhd[1],
                             bhd_lower = 0.5 * bestcost_pm_yld_singlebhd$main$bhd[1],
                             bhd_upper = 1.5 * bestcost_pm_yld_singlebhd$main$bhd[1],
                             duration_central = 10,
                             duration_lower = 5,
                             duration_upper = 15,
                             dw_central = 0.5,
                             dw_lower = 0.25,
                             dw_upper = 0.75)

#View(bestcost_pm_yld_ci)
```


```{r multiple exposure}

# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_additive <-
  bestcost::attribute_health(
    approach_multiexposure = "additive",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    cutoff =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    erf_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_additive,
               result_vector_alternative = 0.081 * 1000)


# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_multiplicative <-
  bestcost::attribute_health(
    approach_multiexposure = "multiplicative",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    cutoff =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    erf_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_multiplicative,
               result_vector_alternative = 0.079 * 1000)
```



### Life table

#### Premature deaths

```{r premature deaths lifetable airqplus input}

# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case

bestcost_pm_deaths_lifetable_airqplus <-
  bestcost::attribute_deaths_from_lifetable(
    approach_exposure = "single_year",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age,
    valuation = 1000)

# View(bestcost_pm_deaths_lifetable_airqplus)

check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus,
                result_vector_alternative = c(2600.9, 1371, 3804))
```



```{r premature deaths lifetable and exposure distribution}

# Calculate premature deaths using bestcost function
bestcost_pm_deaths_lifetable_expDistribution <- 
    bestcost::attribute_deaths_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
      rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
      rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
      rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = 20,
      valuation = 1000)

# View(bestcost_pm_deaths_lifetable_expDistribution)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_expDistribution,
               result_vector_alternative = c(2900, 1531, 4239)) # Result on 20 August 2024
```



#### Years of life lost (YLL)

```{r YLL lifetable from SINGLE YEAR exposure}

# Now with input data from the Swiss project GeLuft
bestcost_pm_yll_exposure_single_year_lifetable_geluft <-
  bestcost::attribute_yll_from_lifetable(
    approach_exposure = "single_year",
    exp_central = input_data_mortality$exp[2], #exp CH 2019
    prop_pop_exp = 1,
    cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2],
    valuation = 1000)

check_bestcost(result_list_bestcost = bestcost_pm_yll_exposure_single_year_lifetable_geluft,
               result_vector_alternative = c(29274.89,	15328.16,	43118.30)) # AirQ+ approach result
               # result_vector_alternative = c(27742, 14641, 40542)) # GeLuft approach result

```



```{r YLL lifetable from CONSTANT exposure and NO NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus <-
  bestcost::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "without_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age,
    valuation = 1000)

# View(bestcost_pm_yll_lifetable_airqplus)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus,
               result_vector_alternative = c(2776839.17,	1452410.83,	4094163.08)) # AirQ+ result
```



```{r YLL lifetable from CONSTANT exposure and WITH NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus_with_newborns <-
  bestcost::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age,
    valuation = 1000)

# View(bestcost_pm_yll_lifetable_airqplus_with_newborns)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus_with_newborns,
               result_vector_alternative = c(3248408.53,	1700230.04,	4786195.41)) # AirQ+ result
```



```{r YLL lifetable with single relative risk}
# Only one relative risk estimate (central estimate)

# Calculate years of life lost using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yll_lifetable_1rr_geluft <- 
    bestcost::attribute_yll_from_lifetable(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff = input_data_mortality$cutoff[2], 
      rr_central = input_data_mortality[2,"rr_central"], 
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2],
      valuation = 1000)

# View(bestcost_pm_yll_lifetable_1rr_geluft)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_1rr_geluft,
               # result_vector_alternative = c(27742)) # GeLuft approach result 
               result_vector_alternative = c(29274.89)) # AirQ+ approach result 
```



```{r YLL lifetable with exposure distribution}

# Calculate years of life lost using bestcost function
# with exposure distribution (instead of population-weighted mean)

bestcost_pm_yll_lifetable_expDistribution_geluft <- 
    bestcost::attribute_yll_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      erf_increment = 10,
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2],
      valuation = 1000)

# View(bestcost_pm_yll_lifetable_expDistribution_geluft)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_expDistribution_geluft ,
               # result_vector_alternative = c(30931, 16337, 45166)) # Result on 16 May 2024 (GeLuft approach)
               result_vector_alternative = c(32704, 17122, 48173)) # Result on 20 August 2024 (AirQ+ approach)

```



#### Years lived with disability (YLD)

```{r YLD lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yld_lifetable_geluft  <- 
  attribute_yld_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    # exp_central = c(8, 9, 10), # Fake data. Deactivate to test exposure distribution.
    prop_pop_exp = 1,
    # prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data. Deactivate to test exposure distribution.
    cutoff = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper = input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure = "single_year",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration = 100, 
    dw_central = 1, dw_lower = 0.1, dw_upper = 10,
    valuation = 1000
  )

# View(bestcost_pm_yld_lifetable_geluft)

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
check_bestcost(result_list_bestcost = bestcost_pm_yld_lifetable_geluft,
               # result_vector_alternative = c(27742, 14641, 40542)) # GeLuft approach result
               result_vector_alternative = c(29274.89,	15328.16,	43118.30)) # AirQ+ approach result

```



#### Disability-adjusted lived years (DALY)

```{r DALY lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_daly_lifetable_geluft  <- 
  attribute_daly_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    prop_pop_exp = 1,
    cutoff = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration = 100, 
    dw_central = 1,
    valuation = 1000
  )

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
# Since DALY = YLL + YLD and in this case YLL=YLD --> DALY = 2*YLL
check_bestcost(result_list_bestcost = bestcost_pm_daly_lifetable_geluft,
               # result_vector_alternative = c(27742*2, 14641*2, 40542*2)) # GeLuft approach result
               result_vector_alternative = c(29274.89*2,	15328.16*2,	43118.30*2)) # AirQ+ approach result


```



## Comparison

### Single bhd

```{r comparison singlebhd_rr}
# Test delta comparison function with fake values
# DELTA

comparison_singlebhd_rr_delta <-
  bestcost::compare_health(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    valuation = 1000)

# View(comparison_singlebhd_rr_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta ,
               result_vector_alternative = c(774, 409, 1127)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_delta_geo <-
  bestcost::compare_health(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_singlebhd_rr_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(1100, 582, 1603)) # Result on 26 June 2024

#PIF
# Test pif comparison function with fake values
comparison_singlebhd_rr_pif <-
  bestcost::compare(
    approach_comparison = "pif",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    valuation = 1000)

# View(comparison_singlebhd_rr_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif ,
               result_vector_alternative = c(782, 412, 1146)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_pif_geo <-
  bestcost::compare_health(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_singlebhd_rr_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(1114, 586, 1634)) # Result on 19 June 2024
```


```{r comparison singlebhd_rr geo iteration, eval=FALSE, include=FALSE}
# Assess iteration in many geographical areas (geo_id) keeping the multiple uncertainties
comparison_singlebhd_rr_geo <-
  bestcost::compare_health(
    approach_comparison = "delta",
    exp_central_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    exp_central_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)),
    exp_lower_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)-0.1),
    exp_upper_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)+0.1),
    cutoff = 5,   
    bhd_central_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_central_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    valuation = 1000)

# View(comparison_singlebhd_rr_geo)
```


```{r comparison ar}

# Test delta comparison function with fake values
# No PIF option in ar
comparison_singlebhd_ar_delta <-
  bestcost::compare_health_ar(
    approach_comparison = "delta",
    exp_central_1 = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    exp_central_2 = c(50, 55, 60, 65, 75), # Fake values
    pop_exp_1 = c(387500, 286000, 191800, 72200, 7700), # Values as example provided by NIPH
    pop_exp_2 = c(387500, 286000, 191800, 72200, 7700), # Fake values
    erf_x_central = "78.9270-3.1162*c+0.0342*c^2",
    valuation = 1000, # Results change with valuation ####
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022)
    )

# View(comparison_singlebhd_ar_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta ,
               result_vector_alternative = c(62531)) # Result on 23 May 2024

comparison_singlebhd_ar_delta_geo <-
  bestcost::compare_health_ar(
    approach_comparison = "delta",
    exp_central_1 = list(c(57.5, 62.5, 67.5, 72.5, 77.5), c(57, 62, 67, 72, 77)),# Fake values
    exp_central_2 = list(c(50, 55, 60, 65, 75), c(50.5, 55.5, 60.5, 65.5, 75.5)), # Fake values
    pop_exp_1 = list(c(387500, 286000, 191800, 72200, 7700), c(380000, 280000, 190800, 72000, 7000)), # Fake values
    pop_exp_2 = list(c(387500, 286000, 191800, 72200, 7700), c(380000, 280000, 190800, 72000, 7000)), # Fake values
    erf_x_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022),
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_singlebhd_ar_delta_geo)

check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta_geo ,
               result_vector_alternative = 115869) # Result on 19 June 2024

```

```{r comparison yld singlebhd_rr}
# DELTA
# Test delta comparison function with fake values
comparison_yld_singlebhd_rr_delta <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    valuation = 1000,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# View(comparison_yld_singlebhd_rr_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta ,
               result_vector_alternative = c(387, 205, 564)) # Result on 16 May 2024

# Additionally check that the first scenario produces the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["main"]]$impact_rounded) 

# Iteration
comparison_yld_singlebhd_rr_delta_geo <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000,)

# View(comparison_yld_singlebhd_rr_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(591, 313, 861)) # Result on 26 June 2024


#PIF
# Test pif comparison function with fake values
comparison_yld_singlebhd_rr_pif <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "pif",
    exp_central_1 = 8.85,  
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    valuation = 1000)

# View(comparison_yld_singlebhd_rr_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif ,
               result_vector_alternative = c(391,206,573)) # Result on 16 May 2024

# Additionally check that the first scenario produces the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["main"]]$impact_rounded) 

# Iteration
comparison_yld_singlebhd_rr_pif_geo <-
  bestcost::compare_yld_from_prevalence(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_yld_singlebhd_rr_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(599, 315, 878)) # Result on 20 June 2024
```



### Lifetable

```{r comparison deaths lifetable, warning=TRUE}

# DELTA

comparison_deaths_lifetable_delta <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    valuation = 1000)

# View(comparison_deaths_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta,
               # result_vector_alternative = c(1922,1017,2801)) # Result on 16 May 2024
               result_vector_alternative = c(1915, 1013, 2795 )) # Result on 20 August 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact_rounded)  

# Iteration
comparison_deaths_lifetable_delta_geo <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2= airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_deaths_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta_geo ,
               # result_vector_alternative = c(2935, 1553, 4279)) # Result on 09 July 2024
               result_vector_alternative = c(2925, 1546, 4269)) # Result on 20 August 2024


# Additionally check that it produces the first scenario produce the same results as above
# comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.) == bestcost_pm_deaths_lifetable_geluft[["main"]]$impact 
round(comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.), digits = 0) == round(bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact)
# Absolute differences
abs(comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.) 
    - bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact)
# Absolute differences are negligeable (< 0.01, or < 0.0001%)
      

# PIF
comparison_deaths_lifetable_pif  <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    approach_exposure_1 = "single_year",
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    approach_exposure_2 = "single_year",
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    min_age = 20,
    valuation = 1000)

# View(comparison_deaths_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif ,
               # result_vector_alternative = c(1943,1023,2847)) # Result on 16 May 2024
               result_vector_alternative = c(1935, 1018, 2837 )) # Result on 20 August 2024

# Additionally check that scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["main"]]$impact_rounded)  # AirQ+ result


# Iteration
comparison_deaths_lifetable_pif_geo <-
  bestcost::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_deaths_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif_geo ,
               # result_vector_alternative = c(2974, 1563, 4362)) # Result on 09 July 2024
               result_vector_alternative = c(2961, 1556, 4346)) # Result on 20 AUgust 2024
```



```{r comparison YLL lifetable}

# DELTA 
comparison_yll_lifetable_delta  <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    approach_newborns_1 = "without_newborns",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019,
    approach_exposure_2 = "single_year",
    approach_newborns_2 = "without_newborns",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    valuation = 1000)

# View(comparison_yll_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta,
               # result_vector_alternative = c(20421,10806,29763)) # Results on 16 May 2024
               result_vector_alternative = c(21644, 11340, 31860)) # Results on 20 August 2024


# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta[["detailed"]][["scenario_1"]] ,
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_exposure_single_year_lifetable_geluft[["main"]]$impact_rounded) # AirQ+ results

# Iteration
comparison_yll_lifetable_delta_geo <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_yll_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta_geo ,
               # result_vector_alternative = c(31190, 16500, 45472)) # Results on 08 July 2024
               result_vector_alternative = c(33041, 17309, 48639)) # Results on 20 August 2024

# PIF
comparison_yll_lifetable_pif <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    valuation = 1000)

# View(comparison_yll_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               # result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024
               result_vector_alternative = c(21698, 11354, 31978 )) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif[["detailed"]][["scenario_1"]],
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_exposure_single_year_lifetable_geluft[["main"]]$impact_rounded)

# Iteration
comparison_yll_lifetable_pif_geo <-
  bestcost::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    valuation = 1000)

# View(comparison_yll_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif_geo ,
               # result_vector_alternative = c(31601, 16613, 46359)) # Result on 08 July 2024
               result_vector_alternative = c(33137, 17335, 48851)) # Result on 20 August 2024
```



```{r comparison YLD lifetable}

# DELTA
comparison_yld_lifetable_delta  <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_yld_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta ,
               # result_vector_alternative = c(20421, 10806, 29763)) # Result on 16 May 2024
               result_vector_alternative = c(21644, 11340, 31860)) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["main"]]$impact_rounded) 

# Iteration
comparison_yld_lifetable_delta_geo <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_yld_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta_geo ,
               # result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024
               result_vector_alternative = c(33041, 17309, 48639)) # Result on 20 August 2024

# PIF
comparison_yld_lifetable_pif <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_yld_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif ,
               # result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024
               result_vector_alternative = c(21698, 11354, 31978)) # Result on 20 August 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["main"]]$impact_rounded)

# Iteration
comparison_yld_lifetable_pif_geo <-
  bestcost::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_yld_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif_geo ,
               # result_vector_alternative = c(31601, 16613, 46359)) # Result on 26 June 2024
               result_vector_alternative = c(33137, 17335, 48851)) # Result on 20 August 2024

```


```{r comparison DALY lifetable}

# DELTA
comparison_daly_lifetable_delta  <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5, # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_daly_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta ,
               # result_vector_alternative = c(20421*2,10806*2,29763*2)) # Result on 16 May 2024
               result_vector_alternative = c(43288, 22679, 63720)) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["main"]]$impact_rounded) 

# Iteration
comparison_daly_lifetable_delta_geo <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_daly_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta_geo ,
               # result_vector_alternative = c(31190*2, 16500*2, 45472*2)) # Result on 08 July 2024
               result_vector_alternative = c(66082, 34618, 97279)) # Result on 20 August 2024

# PIF
comparison_daly_lifetable_pif <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_daly_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif ,
               # result_vector_alternative = c(20650*2, 10870*2, 30257*2)) # Result on 16 May 2024
               result_vector_alternative = c(43396, 22708, 63957 )) # Result on 20 August 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["main"]]$impact_rounded)

# Iteration
comparison_daly_lifetable_pif_geo <-
  bestcost::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration = 100,
    dw_central = 1,
    valuation = 1000)

# View(comparison_daly_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif_geo ,
               # result_vector_alternative = c(31601*2, 16613*2, 46359*2)) # Result on 26 June 2024
               result_vector_alternative = c(66275, 34671, 97702)) # Result on 20 August 2024

```

# Export 

```{r eval=FALSE, include=FALSE}
# write.csv2(lifetable_airqplus,
#             "../testing/output/lifetable_airqplus_2019_ch.csv", 
#             row.names = FALSE)
```

# Other

```{r Illustration integrate compare() in attribute()}

# Benefit of this: compare the two conceptionally different approaches
 
# case1 <- attribute(approach= cutoff in exposure)

# case2 <- attribute(approach = delta approach/cutoff in ERF)

# difference impact <- case1[[impact]] - case2[[impact]]
```
