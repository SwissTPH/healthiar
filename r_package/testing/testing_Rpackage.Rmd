---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---

# Goal
 
Test the functions of the bestcost package comparing the results with results from other tools or assessments

# Load packages and data

The R script required the loading of certain R packages.

```{r Load packages and data, include=FALSE}

## Load required packages
### using {pacman}, which automatically installs packages if not yet installed
library("pacman")
pacman::p_load(
  ## To manipulate data
  readxl, dplyr, tidyr, purrr, stringr, tibble, zoo, stats,
  ## To set colors in console messages (checking)
  crayon,
  ## To load {healthiar}
  credentials, devtools # Not needed anymore: gitcreds
  )

## Load development version of healthiar package
### Only if in development environment! If you're not use option in chunk below
devtools::load_all(export_all = FALSE)

## Load data necessary for running examples below
load("../testing/input/data/input_data_for_testing_Rpackage.RData")
```

```{r Install {healthiar} from GitHub, eval=FALSE, include=FALSE}


## Install own package from GitHub
### Source: https://stackoverflow.com/a/71846333/6104907

## Authenticate yourself using PAT (personal access token)
### See README file at GitHub repo for guidance on how to create a PAT
### https://github.com/best-cost/best-cost_WPs

## NOTE: if an older version of {healthiar} already installed and loaded, detach first 
# detach("package:healthiar", unload = TRUE) # Throws error if package was not loaded


## Option B: Using remotes package (size: 426 KB)
### Advantage: no installation of Git required
credentials::set_github_pat() # paste github PAT if prompted
# ?remotes::install_github
remotes::install_github(
  repo = "best-cost/best-cost_WPs",
  subdir = "/r_package/healthiar",
  # ref = "HEAD", # By default "HEAD"; name of branch to install package from as a string
  ref = "445-installation-error-sasha",
  # ref = "415-prepare-package-for-use-by-ubdpolicy", # By default "HEAD"; name of branch to install package from as a string  
  force = TRUE,
  # auth_token = "", # Paste your GitHub PAT between the quotation marks
  # dependencies = TRUE,
  # build_vignettes = TRUE
)

library(healthiar)

## Option B (outdated): Using devtools package (size: 433 KB) and credentials package
### WARNING: installation of Git required
# credentials::set_github_pat() # paste github PAT if prompted
# credentials::git_credential_forget() # remove PAT
# devtools::install_github(
#   repo = "best-cost/best-cost_WPs",
#   subdir = "/r_package/healthiar",
#   # ref = "HEAD", # By default "HEAD"; name of branch to install package from as a string
#   # ref = "415-prepare-package-for-use-by-ubdpolicy", # By default "HEAD"; name of branch to install package from as a string  
#   force = TRUE,
#   # dependencies = TRUE,
#   build_vignettes = TRUE
# )

```

```{r Install healthiar from local source, eval=FALSE, include=FALSE}

## NOTE: if an older version of {healthiar} already installed and loaded, detach first 
detach("package:healthiar", unload = TRUE) # Throws error if package was not loaded

## Install package from .zip file
devtools::build(binary = TRUE, path = "../testing/input/") # Save current state of package as .zip file (e.g. to directly test changes in functions)
install.packages("../testing/input/healthiar_0.0.0.1.zip", repos=NULL, type='source') # Modify file path

## Install package from .tar.gz file
devtools::build(path = "../testing/input/") # Save current state of package as tar.gz file (e.g. to directly test changes in functions)
install.packages("../testing/input/healthiar_0.0.0.1.tar.gz", repos=NULL, type='source') # Modify file path

library(healthiar)
```


This is test code and should not be run
```{r prepare tests, eval=FALSE, include=FALSE}

data_pop <- base::readRDS(testthat::test_path("data", "pop_data_norway.rds"))
data_erf <- base::readRDS(testthat::test_path("data", "mrbrt_stroke.rds"))


## Gives error
healthiar::attribute_health(
  approach_risk = "relative_risk",
  exp_central = data_pop$Concentration,
  prop_pop_exp = data_pop$Viken,
  bhd_central = 4500,
  erf_eq_central =
    stats::splinefun(
      x = data_erf$exposure,
      y = data_erf$mean,
      method = "natural")
)

## Error in `dplyr::group_by()`:
# ! Must group by variables found in `.data`.
# âœ– Column `cutoff_ci` is not found.


data <- base::readRDS(testthat::test_path("data", "airqplus_pm_copd.rds"))

test <- healthiar::attribute_health(
        approach_multiexposure = "multiplicative",
        exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
        exp_lower = c("pm2.5" = 8.1 - 1, "no2" =  10.9 - 1),
        exp_upper = c("pm2.5" = 8.1 + 1, "no2" =  10.9 + 1),
        cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
        bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
        rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
        rr_lower = setNames(c(1.063, 1.031) - 0.005, c("pm2.5", "no2")),
        rr_upper = setNames(c(1.063, 1.031) + 0.005, c("pm2.5", "no2")),
        rr_increment = setNames(c(10, 10), c("pm2.5", "no2")),
        erf_shape = "log_linear")
    
test <- test |> 
  pluck("health_detailed") |>
  pluck("raw") |>
  select(impact_rounded) |>
  base::unlist() |>
  base::as.numeric()

test <- paste(test, collapse = ", ")
print(test)
```


# Calculate health impacts

## Attributable health impact

### Single baseline health data

```{r single exposure value}
# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = airqplus_pm_copd$mean_concentration-0.5,
    exp_upper = airqplus_pm_copd$mean_concentration+0.5,
    
    cutoff_central = airqplus_pm_copd$cut_off_value,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_copd)

check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result <- 
                 # Store the central, lower and upper estimate of the AirQ+ assessment
                 airqplus_pm_copd |>
                 dplyr::select(estimated_number_of_attributable_cases_central,
                               estimated_number_of_attributable_cases_lower,
                               estimated_number_of_attributable_cases_upper)|>
                 unlist())
```










```{r single exposure value with multiple uncertainties}


bestcost_pm_copd_multiple <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff_central = airqplus_pm_copd$cut_off_value, 
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = 25000,
    bhd_upper = 35000,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    rr_increment = 10, 
    erf_shape = "log_linear",
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

check_bestcost(result_list_bestcost = bestcost_pm_copd_multiple,
               result_vector_alternative = c(3502, 1353, 5474)) # Results on 5 November 2024








# Assess iteration geographical sections keeping the multiple uncertainties
system.time(
  bestcost_pm_copd_geo <-
    healthiar::attribute_health(
      exp_central = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
      exp_lower = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
      exp_upper = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
      cutoff_central = 5,   
      bhd_central = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
      # bhd_lower = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
      bhd_lower = as.list(runif_with_seed(1E4, 20000, 30000, 1)),
      # bhd_upper = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
      bhd_upper = 0,
      rr_central = 1.369, 
      rr_lower = 1.124,
      rr_upper = 1.664,
      rr_increment = 10, 
      erf_shape = "log_linear", 
      population = as.list(rep(1E6, 1E4)),
      geo_id_disaggregated = 1:1E4, 
      geo_id_aggregated = rep("CH", 1E4),
      info = "PM2.5_copd")
  )

# View(bestcost_pm_copd_geo)
check_bestcost(result_list_bestcost = bestcost_pm_copd_geo,
               result_vector_alternative = c(31460722, 12120764, 49312859)) # Results on 5 November 2024

# Assess iteration geographical sections keeping the multiple uncertainties
system.time(bestcost_pm_copd_geo_short <-
  healthiar::attribute_health(
    exp_central = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)+0.1),
    cutoff_central = 5,   
    bhd_central = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    bhd_lower = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    bhd_upper = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_disaggregated = 1:1E1, 
    geo_id_aggregated = rep("CH", 1E1),
    info = "PM2.5_copd"))

# View(bestcost_pm_copd_geo_short)
check_bestcost(result_list_bestcost = bestcost_pm_copd_geo_short,
               result_vector_alternative = c(32449, 12508, 50836)) # Results on 5 November 2024
```

```{r single exposure & user-defined points for relative risk using splinefun}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_alri_erf_dots_splinefun <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    # cutoff_central = 0,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    # GBD2019 ERF for PM and lower respiratory infections
    erf_eq_central = 
      stats::splinefun(
        x = c(600,500,400,300,200,150,130,110,90,70,50,30,25,20,15,10,5,0),
        y = c(2.189,2.143,2.098,2.052,1.909,1.751,1.68,1.607,1.533,1.453,1.357,1.238,1.204,1.168,1.129,1.089,1.046,	1),
        method = "natural"),
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_alri_erf_dots_splinefun)

# check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_splinefun,
#                result_vector_alternative = c(2263)) # Results on 10 October 2024 (with cutoff = 0)
check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_splinefun,
               result_vector_alternative = c(1057)) # Results on 10 October 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value)
```

```{r single exposure & user-defined points for relative risk using approxfun}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_alri_erf_dots_approxfun <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    # cutoff_central = 0,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    # GBD2019 ERF for PM and lower respiratory infections
    erf_eq_central = 
      stats::approxfun(
        x = c(600,500,400,300,200,150,130,110,90,70,50,30,25,20,15,10,5,0),
        y = c(2.189,2.143,2.098,2.052,1.909,1.751,1.68,1.607,1.533,1.453,1.357,1.238,1.204,1.168,1.129,1.089,1.046,	1),
        method = "linear"),
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_alri_erf_dots_approxfun)

# check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_approxfun,
#                result_vector_alternative = c(2254)) # Results on 10 October 2024 (with cutoff = 0)
check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_approxfun,
               result_vector_alternative = c(1052)) # Results on 10 October 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value)
```

```{r single exposure value and relative risk with monetization}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd_1rr <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_1rr_result <- 
  airqplus_pm_copd |>
  dplyr::select(estimated_number_of_attributable_cases_central)|>
  unlist()

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```

```{r exposure distribution with rr}

# Extract rows that contain input data (others may contain results)
niph_noise_ihd_input <- 
  niph_noise_ihd_excel |>
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ihd_result <- 
  niph_noise_ihd_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(daly)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  healthiar::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    # exp_lower = niph_noise_ihd_input$exposure_mean - 2,
    # exp_upper = niph_noise_ihd_input$exposure_mean + 2,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff_central = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    # rr_lower = 1.08 - 0.02,
    # rr_upper = 1.08 + 0.02,
    rr_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))

# View(bestcost_noise_ihd_expDist)

check_bestcost(result_list_bestcost = bestcost_noise_ihd_expDist,
               result_vector_alternative = niph_noise_ihd_result)

 
# Obtain attributable cases using the bestcost package
# for multiple geo_sections
bestcost_noise_ihd_expDist_geo <- 
  healthiar::attribute_health(
    exp_central = list(runif_with_seed(5,8,10,1), 
                       runif_with_seed(5,8,10,2), 
                       runif_with_seed(5,8,10,3)),
    cutoff_central = 5,
    prop_pop_exp = list(runif_with_seed(5,0.1,1,1),
                        runif_with_seed(5,0.1,1,2), 
                        runif_with_seed(5,0.1,1,3)),
    bhd_central = list(runif_with_seed(3,1E4,1E5,1)),
    rr_central = 1.08,
    rr_increment = 10, 
    erf_shape = "log_linear",
    geo_id_disaggregated = 1:3,
    geo_id_aggregated = rep("ch", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

# View(bestcost_noise_ihd_expDist_geo)
```

```{r exposure distribution and user-defined points for relative risk}

bestcost_pm_stroke_mr_brt <-
  healthiar::attribute_health(
    approach_risk = "relative_risk",
    exp_central = pop_data_norway$Concentration,
    prop_pop_exp = pop_data_norway$Viken,
    # cutoff_central = 5,
    cutoff_central = 0,
    bhd_central = 4500,
    erf_eq_central = 
      stats::splinefun(
        x = mrbrt_stroke$exposure,
        y = mrbrt_stroke$mean,
        method = "natural"),
    erf_eq_lower = stats::splinefun(
        x = mrbrt_stroke$exposure,
        y = mrbrt_stroke$mean,
        method = "natural"),
    erf_eq_upper = stats::splinefun(
        x = mrbrt_stroke$exposure,
        y = mrbrt_stroke$mean + 0.01,
        method = "natural")
    )

# View(bestcost_pm_stroke_niph)

# View(bestcost_pm_stroke_mr_brt)

check_bestcost(result_list_bestcost = bestcost_pm_stroke_mr_brt,
               result_vector_alternative = c(249,249,289)) # Results on 17 October 2024 (with cutoff = 0)
# check_bestcost(result_list_bestcost = bestcost_pm_stroke_mr_brt,
               # result_vector_alternative = c(32)) # Results on 17 October 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value),
               # result_vector_alternative = c(32,32,76)) # Results on 19 December 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value) & erf_eq uncertainty

```

```{r absolute risk}

# Extract rows that contain input data (others may contain results)
niph_noise_ha_input <-
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ha_result <- 
  niph_noise_ha_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(number)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ha_ar <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    # exp_lower = niph_noise_ha_input$exposure_mean - 1,
    # exp_upper = niph_noise_ha_input$exposure_mean + 1,
    cutoff_central = 10,
    population = sum(niph_noise_ha_input$population_exposed_total), 
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

# View(bestcost_noise_ha_ar)

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result)

# YLD case for absolute risk
bestcost_noise_ha_ar_yld <- 
  healthiar::attribute_yld(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    population = sum(niph_noise_ha_input$population_exposed_total), 
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10,
    # dw_central = 1, dw_lower = 0.1, dw_upper = 10,
    duration_central = 1, #duration_lower = 0.1, duration_upper = 10,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar_yld,
               result_vector_alternative = niph_noise_ha_result/2)

# Obtain attributable cases using the bestcost package and input data from niph
# for multiple geo_sections
bestcost_noise_ha_ar_geo <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = list(runif_with_seed(5,8,10,1), 
                          runif_with_seed(5,8,10,2), 
                          runif_with_seed(5,8,10,3)),
            exp_lower = list(runif_with_seed(5,8,10,1) - 5,
                         runif_with_seed(5,8,10,2) - 5,
                         runif_with_seed(5,8,10,3) - 5),
        exp_upper = list(runif_with_seed(5,8,10,1) + 5,
                         runif_with_seed(5,8,10,2) + 5,
                         runif_with_seed(5,8,10,3) + 5),
    population = list(runif_with_seed(1,5E3,1E4,1),
                        runif_with_seed(1,5E3,1E4,2), 
                        runif_with_seed(1,5E3,1E4,3)),
    prop_pop_exp = list(runif_with_seed(5,0,1,1),
                        runif_with_seed(5,0,1,2), 
                        runif_with_seed(5,0,1,3)), 
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_disaggregated = 1:3,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))
```

```{r YLD with single relative risk}

## prevalence-based YLD (duration_central=1)
bestcost_pm_yld_singlebhd  <- 
  healthiar::attribute_yld(
    exp_central = 8.85, 
    cutoff_central = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10,
    duration_central = 1, duration_lower = 0.5, duration_upper = 10)

# View(bestcost_pm_yld_singlebhd)

# No study to compare bestcost results
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd ,
               result_vector_alternative = c(525, 277, 768)) # Result on 16 May 2024

## incidence-based YLD (duration_central > 1)
bestcost_pm_yld_singlebhd  <- 
  healthiar::attribute_yld(
    exp_central = 8.85, 
    cutoff_central = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10,
    duration_central = 5, duration_lower = 2, duration_upper = 10)

# View(bestcost_pm_yld_singlebhd)

# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd,
               result_vector_alternative = c(2627, 1386, 3839 )) # Result on 2025-01-28
```

# Social analysis

```{r Social analysis using attribute output}
# Take into account social aspects

# First calculate attributable deahts based on total mortality as provide by Sciensano
bestcost_pm_death <- 
  healthiar::attribute_health(
    exp_central = as.list(social_data$PM25_MEAN),
    cutoff_central = 0,
    rr_central = 1.08, # The data set contains the RR for the exposure but not per increment. Calculable as e.g. exp(log(1.038017)/(4.848199)*10) 
    erf_shape = "log_linear", 
    rr_increment = 10,
    bhd_central = as.list(social_data$MORTALITY_TOTAL),
    population = social_data$POPULATION,
    geo_id_disaggregated = social_data$CS01012020)

# Then include social indicators of deprivation 
bestcost_pm_death_social_decile <- 
  healthiar::include_social(output_healthiar = bestcost_pm_death,
                            geo_id_disaggregated = social_data$CS01012020,
                            social_indicator = social_data$score,
                            n_quantile = 10,
                            approach = "quantile")

#View(bestcost_pm_death_social_decile)

# Check that results did not change over time
check_general(
  a = bestcost_pm_death_social_decile[["social_main"]]$difference_value,
  b = c(22.52416423, 0.32236823, 14.5680866,0.17252793)  # Results on 21 Nov 2024
  )

```

```{r Social analysis using impact vector, eval=FALSE, include=FALSE}
# Take into account social aspects

# First calculate attributable deahts based on total mortality as provide by Sciensano
bestcost_pm_death <- 
  healthiar::attribute_health(
    exp_central = as.list(social_data$PM25_MEAN),
    cutoff_central = 0,
    rr_central = 1.08, # The data set contains the RR for the exposure but not per increment. Calculable as e.g. exp(log(1.038017)/(4.848199)*10) 
    erf_shape = "log_linear", 
    rr_increment = 10,
    bhd_central = as.list(social_data$MORTALITY_TOTAL),
    population = social_data$POPULATION,
    geo_id_disaggregated = social_data$CS01012020)

# Then include social indicators of deprivation 
bestcost_pm_death_social_decile_impact_vector <- 
  healthiar::include_social(impact = bestcost_pm_death[["health_main"]]$impact,
                            population = bestcost_pm_death[["health_main"]]$population,
                            bhd = bestcost_pm_death[["health_main"]]$bhd,
                            exp = bestcost_pm_death[["health_main"]]$exp,
                            pop_fraction = bestcost_pm_death[["health_main"]]$pop_fraction,
                            geo_id_disaggregated = social_data$CS01012020,
                            social_indicator = social_data$score,
                            n_quantile = 10,
                            approach = "quantile")

View(bestcost_pm_death_social_decile_impact_vector)

# Check that results did not change over time
check_general(
  a = bestcost_pm_death_social_decile_impact_vector[["social_main"]]$difference_value,
  b = c(22.52416423, 0.32236823, 14.5680866,0.17252793)  # Results on 21 Nov 2024
  )

```

```{r get_mdi}

# Load dataset
## Sciensano
# data <- read.csv("//sciensano.be/fs/1147_BESTCOST_Employee/03_Content/WP3/Task3.1/Analysis/Belgium_MDI_2021.csv")
## Swiss TPH
data <- read.csv("../testing/MDI_code_from_WP3/Belgium_MDI_2021.csv")
str(data)

mdi <- healthiar::get_mdi(
  geo_id_disaggregated = data$id,
  edu = data$edu,
  unemployed = data$unemployed,
  single_parent = data$single_parent,
  pop_change = data$pop_change,
  no_heating = data$no_heating,
  n_quantile = 10)

## Validate calculation of get_mdi with the following code function psych::alpha
# Install and load the psych package (if not already installed)
reliability <- psych::alpha(
  data |> dplyr::select(norm_edu, norm_unemployed, norm_single_parent, norm_pop_change, norm_no_heating))
print(reliability$total |> dplyr::pull(raw_alpha))

```


# Summary uncertainty

```{r Summary uncertainty rr single exposure attribute_health }

bestcost_pm_copd_with_summary_uncertainty <- 
  healthiar::attribute_health(
    exp_central = 8.85, 
    exp_lower = airqplus_pm_copd$mean_concentration - 1,
    exp_upper = airqplus_pm_copd$mean_concentration + 1,
    cutoff_central = 5,
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) - 5000,
    bhd_upper = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) + 5000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear"
    )

# View(bestcost_pm_copd_with_summary_uncertainty)

bestcost_pm_copd_extern_uncertainty <-
  healthiar::include_summary_uncertainty(
    res = bestcost_pm_copd_with_summary_uncertainty,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
## Central estimates
print("Main estimates: ") ; bestcost_pm_copd_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
## With external uncertainty function (i.e. include_summary_uncertainty())
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_pm_copd_extern_uncertainty[["uncertainty_main"]]), digits = 0)
bestcost_pm_copd_extern_uncertainty |>
    purrr::pluck("uncertainty_main") |>
    base::as.numeric() |> 
    round(digits = 0)
# Results of internal Monte-Carlo summary uncertainty and extern Monte-Carlo summary uncertainty identical!
```

```{r Summary uncertainty rr single exposure iteration}

# Assess iteration geographical sections keeping the multiple uncertainties
bestcost_pm_copd_geo_short <-
  healthiar::attribute_health(
    exp_central = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)+0.1),
    cutoff_central = 5,
    # cutoff_lower = 4,
    # cutoff_upper = 6,
    bhd_central = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    # bhd_lower = as.list(runif_with_seed(1E1, 20000, 30000, 1)),
    # bhd_upper = as.list(runif_with_seed(1E1, 30000, 40000, 1)) ,
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_disaggregated = 1:1E1, 
    geo_id_aggregated = rep("CH", 1E1),
    info = "PM2.5_copd")

# View(bestcost_pm_copd_geo_short)
check_bestcost(result_list_bestcost = bestcost_pm_copd_geo_short,
               result_vector_alternative = c(32449, 12508, 50836)) # Results on 5 November 2024

bestcost_pm_copd_geo_short_uncertainty <- 
  healthiar::include_summary_uncertainty(
    bestcost_pm_copd_geo_short,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ") ; bestcost_pm_copd_geo_short[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_pm_copd_geo_short_uncertainty[["uncertainty_main"]]), digits = 0)
# Results seem plausible
```



```{r Summary uncertainty rr & exposure distribution}

# Data prep
niph_noise_ihd_input <- 
  niph_noise_ihd_excel |>
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))
niph_noise_ihd_result <- 
  niph_noise_ihd_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(daly)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  healthiar::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    # exp_lower = niph_noise_ihd_input$exposure_mean - 2,
    # exp_upper = niph_noise_ihd_input$exposure_mean + 2,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff_central = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    rr_lower = 1.08 - 0.02,
    rr_upper = 1.08 + 0.02,
    rr_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))

# View(bestcost_noise_ihd_expDist)

# Calculate summary uncertainty
bestcost_noise_ihd_expDist_extern_uncertainty <- include_summary_uncertainty(
  bestcost_noise_ihd_expDist,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ") ; bestcost_noise_ihd_expDist[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ihd_expDist_extern_uncertainty[["uncertainty_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty rr exposure distribution iteration}

# Data prep
niph_noise_ihd_input <- 
  niph_noise_ihd_excel |>
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist_iteration <- 
  healthiar::attribute_health(
    exp_central = list(niph_noise_ihd_input$exposure_mean,
                       niph_noise_ihd_input$exposure_mean + 5,
                       niph_noise_ihd_input$exposure_mean + 10),
    exp_lower = list(niph_noise_ihd_input$exposure_mean - 2,
                     niph_noise_ihd_input$exposure_mean + 5 - 2,
                     niph_noise_ihd_input$exposure_mean + 10 - 2),
    exp_upper = list(niph_noise_ihd_input$exposure_mean + 2,
                     niph_noise_ihd_input$exposure_mean + 5 + 2,
                     niph_noise_ihd_input$exposure_mean + 10 + 2),
    prop_pop_exp = list(niph_noise_ihd_input$prop_exposed,
                        niph_noise_ihd_input$prop_exposed,
                        niph_noise_ihd_input$prop_exposed),
    cutoff_central = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = list(niph_noise_ihd_input$gbd_daly[1], 
                       niph_noise_ihd_input$gbd_daly[1] + 5000,
                       niph_noise_ihd_input$gbd_daly[1] + 10000),
    rr_central = 1.08,
    # rr_lower = 1.08 - 0.02,
    # rr_upper = 1.08 + 0.02,
    rr_increment = 10, 
    erf_shape = "log_linear",
    geo_id_disaggregated = 1:3, 
    geo_id_aggregated = rep("CH", 3),
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))
# View(bestcost_noise_ihd_expDist_iteration)

bestcost_noise_ihd_expDist_iteration_uncertainty <- include_summary_uncertainty(
  bestcost_noise_ihd_expDist_iteration,
    n_sim = 100)
# View(bestcost_noise_ihd_expDist_iteration_uncertainty)


## Check impacts per geo unit
### Central estimates from attribte()
round(as.numeric(bestcost_noise_ihd_expDist_iteration[["health_detailed"]][["raw"]] |> filter(erf_ci == "central") |> filter(exp_ci == "central") |> pull(impact_rounded)), digits = 0) 
### Summary uncertainty estimates from include_summary_uncertainty()
round(as.numeric(bestcost_noise_ihd_expDist_iteration_uncertainty[["uncertainty_detailed"]][["geo_specific"]]$impact_central), digits = 0)
### Results seem plausible

## Check PAFs  of geo units
print("Main (PAF's of 1st/2nd/3rd geo unit)")
bestcost_noise_ihd_expDist_iteration[["health_detailed"]][["raw"]] |> filter(erf_ci == "central") |> filter(exp_ci == "central") |> pull(pop_fraction)
## The PAFs from the attribute call of the different geo units match with the one obtained in the example_road_noise_niph_test.xlsx

## Check aggregated impact
print("Main estimate: ") ; bestcost_noise_ihd_expDist_iteration[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ihd_expDist_iteration_uncertainty[["uncertainty_main"]] |> pull(central_estimate)), digits = 0)
## Results seem plausible
```

```{r Summary uncertainty rr attribute_yld}

bestcost_pm_yld_singlebhd_with_summary_uncertainty  <- 
  healthiar::attribute_yld(
    exp_central = 8.85, 
    exp_lower = airqplus_pm_copd$mean_concentration - 1,
    exp_upper = airqplus_pm_copd$mean_concentration + 1,
    cutoff_central = 5,
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) - 5000,
    bhd_upper = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) + 5000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    # dw_central = 0.9, dw_lower = 0.88, dw_upper = 0.93,
    dw_central = 0.5, dw_lower = 0.25, dw_upper = 0.75,
    duration_central = 1
    )

bestcost_pm_yld_singlebhd_external_summary_uncertainty <- healthiar::include_summary_uncertainty(
  bestcost_pm_yld_singlebhd_with_summary_uncertainty,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
# View(bestcost_pm_yld_singlebhd_with_summary_uncertainty)
print("Main estimates: ") ; bestcost_pm_yld_singlebhd_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (external function): ")
round(as.numeric(bestcost_pm_yld_singlebhd_external_summary_uncertainty[["uncertainty_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty ar}

# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Internal get_ci function
bestcost_noise_ha_ar_with_summary_uncertainty <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    exp_lower = niph_noise_ha_input$exposure_mean - 1,
    exp_upper = niph_noise_ha_input$exposure_mean + 1,
    population = sum(niph_noise_ha_input$population_exposed_total),
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total), 
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance")
    )
# View(bestcost_noise_ha_ar_with_summary_uncertainty)

bestcost_noise_ha_ar_external_uncertainty <- healthiar::include_summary_uncertainty(
  bestcost_noise_ha_ar_with_summary_uncertainty,
  n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ")
bestcost_noise_ha_ar_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
# External include_summary_uncertainty function
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ha_ar_external_uncertainty[["uncertainty_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty ar iteration}

# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Internal get_ci function
bestcost_noise_ha_ar_iteration <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = list(niph_noise_ha_input$exposure_mean,
                       niph_noise_ha_input$exposure_mean + 5,
                       niph_noise_ha_input$exposure_mean + 10),
    exp_lower = list(niph_noise_ha_input$exposure_mean -2,
                       niph_noise_ha_input$exposure_mean + 5 - 2,
                       niph_noise_ha_input$exposure_mean + 10 - 2),
    exp_upper = list(niph_noise_ha_input$exposure_mean + 2,
                       niph_noise_ha_input$exposure_mean + 5 + 2,
                       niph_noise_ha_input$exposure_mean + 10 + 2),
    prop_pop_exp = list(niph_noise_ha_input$population_exposed_total, 
                   niph_noise_ha_input$population_exposed_total + 0.1,
                   niph_noise_ha_input$population_exposed_total + 0.2),
    population = list(runif_with_seed(1,5E3,1E4,1),
                        runif_with_seed(1,5E3,1E4,2), 
                        runif_with_seed(1,5E3,1E4,3)),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_disaggregated = 1:3, 
    geo_id_aggregated = rep("CH", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"),
    )
# View(bestcost_noise_ha_ar_with_summary_uncertainty)

bestcost_noise_ha_ar_iteration_with_summary_uncertainty <-
  healthiar::include_summary_uncertainty(
    res = bestcost_noise_ha_ar_iteration,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
# View(bestcost_pm_yld_singlebhd_with_summary_uncertainty)
print("Main estimates: ") ; bestcost_noise_ha_ar_iteration_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (external function): ")
round(as.numeric(bestcost_noise_ha_ar_iteration_with_summary_uncertainty[["uncertainty_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty ar YLD}

# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# YLD case for absolute risk
bestcost_noise_ha_ar <- 
  healthiar::attribute_yld(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    population = sum(niph_noise_ha_input$population_exposed_total), 
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    dw_central = 0.5, dw_lower = 0.25, dw_upper = 0.75,
    duration_central = 1, duration_lower = 0.1, duration_upper = 10,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

bestcost_noise_ha_ar_external_uncertainty <- healthiar::include_summary_uncertainty(
  bestcost_noise_ha_ar,
  n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ")
bestcost_noise_ha_ar[["health_main"]][["impact_rounded"]]
# External include_summary_uncertainty function
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ha_ar_external_uncertainty[["uncertainty_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty ar single geo unit erf_eq uncertainty}


# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Internal get_ci function
bestcost_noise_ha_ar_with_erf_eq <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    # exp_lower = niph_noise_ha_input$exposure_mean -2,
    # exp_upper = niph_noise_ha_input$exposure_mean + 2,
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total),
    population = sum(niph_noise_ha_input$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    erf_eq_lower = "78.9270-3.1162*c+0.034*c^2",
    erf_eq_upper = "78.9270-3.1162*c+0.04*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"),
    )
# View(bestcost_noise_ha_ar_with_erf_eq)

bestcost_noise_ha_ar_with_erf_eq_mc <-
  healthiar::include_summary_uncertainty(
    res = bestcost_noise_ha_ar_with_erf_eq,
    n_sim = 1000)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
# View(bestcost_pm_yld_singlebhd_with_summary_uncertainty)
print("Main estimates: ") ; bestcost_noise_ha_ar_with_erf_eq[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (external function): ")
round(as.numeric(bestcost_noise_ha_ar_with_erf_eq_mc[["uncertainty_main"]]), digits = 0)
# Summary uncertainty result seems too low (it is only around half of the attribute result). 
# However, I'm not sure if we can expect the results to be exactly the same with the methodology implemented... 

```

```{r Summary uncertainty ar iteration erf_eq uncertainty}


# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Internal get_ci function
bestcost_noise_ha_ar_iteration_with_erf_eq <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = list(niph_noise_ha_input$exposure_mean,
                       niph_noise_ha_input$exposure_mean + 5,
                       niph_noise_ha_input$exposure_mean + 10),
    # exp_lower = list(niph_noise_ha_input$exposure_mean -2,
    #                    niph_noise_ha_input$exposure_mean + 5 - 2,
    #                    niph_noise_ha_input$exposure_mean + 10 - 2),
    # exp_upper = list(niph_noise_ha_input$exposure_mean + 2,
    #                    niph_noise_ha_input$exposure_mean + 5 + 2,
    #                    niph_noise_ha_input$exposure_mean + 10 + 2),
    prop_pop_exp = list(niph_noise_ha_input$population_exposed_total, 
                   niph_noise_ha_input$population_exposed_total + 0.1,
                   niph_noise_ha_input$population_exposed_total + 0.2),
    population = list(runif_with_seed(1,5E3,1E4,1),
                        runif_with_seed(1,5E3,1E4,2), 
                        runif_with_seed(1,5E3,1E4,3)),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    erf_eq_lower = "78.9270-3.1162*c+0.034*c^2",
    erf_eq_upper = "78.9270-3.1162*c+0.04*c^2",
    geo_id_disaggregated = 1:3, 
    geo_id_aggregated = rep("CH", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"),
    )
# View(bestcost_noise_ha_ar_iteration_with_erf_eq)

bestcost_noise_ha_ar_iteration_with_erf_eq_mc <-
  healthiar::include_summary_uncertainty(
    res = bestcost_noise_ha_ar_iteration_with_erf_eq,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
# View(bestcost_pm_yld_singlebhd_with_summary_uncertainty)
print("Main estimates: ") ; bestcost_noise_ha_ar_iteration_with_erf_eq[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (external function): ")
round(as.numeric(bestcost_noise_ha_ar_iteration_with_erf_eq_mc[["uncertainty_main"]]), digits = 0)
# Summary uncertainty  result seems too low (it is only around half of the attribute result). 
# However, I'm not sure if we can expect the results to be exactly the same with the methodology implemented... 

```

### Multiple exposure

```{r additive approach}
# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_additive <-
  healthiar::attribute_health(
    approach_multiexposure = "additive",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    exp_lower = c("pm2.5" = 8.1 - 1, "no2" =  10.9 - 1),
    exp_upper = c("pm2.5" = 8.1 + 1, "no2" =  10.9 + 1),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    rr_lower = setNames(c(1.063, 1.031)- 0.001, c("pm2.5", "no2")),
    rr_upper = setNames(c(1.063, 1.031) + 0.001, c("pm2.5", "no2")),
    rr_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

View(bestcost_pm_no2_mortality_additive)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_additive,
               result_vector_alternative = 0.081 * 1000)
```

```{r multiplicative approach}
# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_multiplicative <-
  healthiar::attribute_health(
    approach_multiexposure = "multiplicative",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    # exp_lower = c("pm2.5" = 8.1 - 1, "no2" =  10.9 - 1),
    # exp_upper = c("pm2.5" = 8.1 + 1, "no2" =  10.9 + 1),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    # rr_lower = setNames(c(1.063, 1.031)- 0.001, c("pm2.5", "no2")),
    # rr_upper = setNames(c(1.063, 1.031) + 0.001, c("pm2.5", "no2")),
    rr_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

View(bestcost_pm_no2_mortality_multiplicative)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_multiplicative,
               result_vector_alternative = 0.079 * 1000)


# Assess attributable cases using the BEST-COST task 1.4 report
# Attention fake rr and exp conficence interval data (only for testing purposes)
bestcost_pm_no2_mortality_multiplicative_ci <-
  healthiar::attribute_health(
    approach_multiexposure = "multiplicative",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    exp_lower = c("pm2.5" = 7, "no2" =  9),
    exp_upper = c("pm2.5" = 9, "no2" =  12),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    rr_lower = setNames(c(1.05, 1.02), c("pm2.5", "no2")),
    rr_upper = setNames(c(1.07, 1.04), c("pm2.5", "no2")),
    rr_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_multiplicative_ci,
               result_vector_alternative = c(79,59,93)) # Results on 21.01.2025
```

```{r combined approach}
# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_combined <-
  healthiar::attribute_health(
    approach_multiexposure = "combined",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    # exp_lower = c("pm2.5" = 8.1 - 1, "no2" =  10.9 - 1),
    # exp_upper = c("pm2.5" = 8.1 + 1, "no2" =  10.9 + 1),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    # rr_lower = setNames(c(1.063, 1.031)- 0.001, c("pm2.5", "no2")),
    # rr_upper = setNames(c(1.063, 1.031) + 0.001, c("pm2.5", "no2")),
    rr_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

View(bestcost_pm_no2_mortality_multiplicative)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_multiplicative,
               result_vector_alternative = 0.079 * 1000)

# Assess attributable cases using the BEST-COST task 1.4 report
# Attention fake rr and exp conficence interval data (only for testing purposes)
bestcost_pm_no2_mortality_combined_ci <-
  healthiar::attribute_health(
    approach_multiexposure = "combined",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    exp_lower = c("pm2.5" = 7, "no2" =  9),
    exp_upper = c("pm2.5" = 9, "no2" =  12),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    rr_lower = setNames(c(1.05, 1.02), c("pm2.5", "no2")),
    rr_upper = setNames(c(1.07, 1.04), c("pm2.5", "no2")),
    rr_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_combined_ci,
               result_vector_alternative = c(79,59,93)) # Results on 21.01.2025
```

### Life table

#### Premature deaths

```{r premature deaths lifetable airqplus input}

# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case

bestcost_pm_deaths_lifetable_airqplus <-
  healthiar::attribute_deaths_from_lifetable(
    approach_exposure = "single_year",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff_central = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    rr_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# View(bestcost_pm_deaths_lifetable_airqplus)

check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus,
                result_vector_alternative = c(2601, 1371, 3804))
```

```{r premature deaths lifetable and exposure distribution}

# Calculate premature deaths using bestcost function
bestcost_pm_deaths_lifetable_expDistribution <- 
    healthiar::attribute_deaths_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff_central = input_data_mortality$cutoff[2],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
      rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
      rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
      rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
      rr_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = 20)

# View(bestcost_pm_deaths_lifetable_expDistribution)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_expDistribution,
               result_vector_alternative = c(2900, 1531, 4239)) # Result on 20 August 2024
```

#### Years of life lost (YLL)

```{r YLL lifetable from SINGLE YEAR exposure}

# Now with input data from the Swiss project GeLuft
bestcost_pm_yll_exposure_single_year_lifetable_geluft <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "single_year",
    exp_central = input_data_mortality$exp[2], #exp CH 2019
    prop_pop_exp = 1,
    cutoff_central = input_data_mortality$cutoff[2], # WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_exposure_single_year_lifetable_geluft,
               result_vector_alternative = c(29274.89,	15328.16,	43118.30)) # AirQ+ approach result
               # result_vector_alternative = c(27742, 14641, 40542)) # GeLuft approach result



```

```{r YLL lifetable from CONSTANT exposure and NO NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "without_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff_central = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    rr_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    # time_horizon = 100,
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age#,
    #max_age = 99
    )

# View(bestcost_pm_yll_lifetable_airqplus)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus,
               result_vector_alternative = c(2776839.17,	1452410.83,	4094163.08)) # AirQ+ result
```

```{r YLL lifetable from CONSTANT exposure and WITH NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus_with_newborns <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff_central = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    rr_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# View(bestcost_pm_yll_lifetable_airqplus_with_newborns)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus_with_newborns,
               result_vector_alternative = c(3248408.53,	1700230.04,	4786195.41)) # AirQ+ result
```

```{r YLL lifetable with single relative risk}
# Only one relative risk estimate (central estimate)

# Calculate years of life lost using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yll_lifetable_1rr_geluft <- 
    healthiar::attribute_yll_from_lifetable(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff_central = input_data_mortality$cutoff[2], 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

# View(bestcost_pm_yll_lifetable_1rr_geluft)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_1rr_geluft,
               # result_vector_alternative = c(27742)) # GeLuft approach result 
               result_vector_alternative = c(29274.89)) # AirQ+ approach result 
```

```{r YLL lifetable with exposure distribution}

# Calculate years of life lost using bestcost function
# with exposure distribution (instead of population-weighted mean)

bestcost_pm_yll_lifetable_expDistribution_geluft <- 
    healthiar::attribute_yll_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff_central = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      rr_increment = 10,
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

# View(bestcost_pm_yll_lifetable_expDistribution_geluft)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_expDistribution_geluft ,
               # result_vector_alternative = c(30931, 16337, 45166)) # Result on 16 May 2024 (GeLuft approach)
               result_vector_alternative = c(32704, 17122, 48173)) # Result on 20 August 2024 (AirQ+ approach)

```

#### Years lived with disability (YLD)

```{r YLD lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yld_lifetable_geluft  <- 
  attribute_yld_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    # exp_central = c(8, 9, 10), # Fake data. Deactivate to test exposure distribution.
    prop_pop_exp = 1,
    # prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data. Deactivate to test exposure distribution.
    cutoff_central = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper = input_data_mortality[2,"rr_upper"], 
    rr_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure = "single_year",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration_central = 100, 
    duration_lower = 50, duration_upper = 100, 
    dw_central = 1 #, dw_lower = 0.1, dw_upper = 10
)

# View(bestcost_pm_yld_lifetable_geluft)

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
check_bestcost(result_list_bestcost = bestcost_pm_yld_lifetable_geluft,
               # result_vector_alternative = c(27742, 14641, 40542)) # GeLuft approach result
               result_vector_alternative = c(29274.89,	15328.16,	43118.30)) # AirQ+ approach result

```

#### Disability-adjusted lived years (DALY)

```{r DALY lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_daly_lifetable_geluft  <- 
  attribute_daly_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    prop_pop_exp = 1,
    cutoff_central = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration_central = 100, 
    dw_central = 1)

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
# Since DALY = YLL + YLD and in this case YLL=YLD --> DALY = 2*YLL
check_bestcost(result_list_bestcost = bestcost_pm_daly_lifetable_geluft,
               # result_vector_alternative = c(27742*2, 14641*2, 40542*2)) # GeLuft approach result
               result_vector_alternative = c(29274.89*2,	15328.16*2,	43118.30*2)) # AirQ+ approach result


```

## Comparison

### Single bhd

```{r comparison singlebhd_rr}



# Test delta comparison function with fake values
# DELTA

comparison_singlebhd_rr_delta <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# View(comparison_singlebhd_rr_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta ,
               result_vector_alternative = c(774, 409, 1127)) # Result on 16 May 2024


# With same impact to test that there is no error.
comparison_singlebhd_rr_delta_same_impact <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 8.85,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_same_impact ,
               result_vector_alternative = c(0, 0, 0)) # Result on 27 Nov 2024

# With iteration
comparison_singlebhd_rr_delta_geo <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_singlebhd_rr_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(1100, 582, 1603)) # Result on 26 June 2024

#PIF
# Test pif comparison function with fake values
comparison_singlebhd_rr_pif <-
  healthiar::compare(
    approach_comparison = "pif",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# View(comparison_singlebhd_rr_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif ,
               result_vector_alternative = c(782, 412, 1146)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_pif_geo <-
  healthiar::compare_health(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_singlebhd_rr_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(1114, 586, 1634)) # Result on 19 June 2024
```

```{r comparison singlebhd_rr geo iteration, eval=FALSE, include=FALSE}
# Assess iteration in many geographical areas (geo_id) keeping the multiple uncertainties
comparison_singlebhd_rr_geo <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    exp_central_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)),
    exp_lower_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)-0.1),
    exp_upper_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)+0.1),
    cutoff_central = 5,   
    bhd_central_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_central_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_disaggregated = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# View(comparison_singlebhd_rr_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_geo,
               result_vector_alternative = c(211111, 84203, 319618)) # Result on 19 December 2024
```

```{r comparison ar}

# Test delta comparison function with fake values
# No PIF option in ar
comparison_singlebhd_ar_delta <-
  healthiar::compare_health(
    approach_risk = "absolute_risk",
    approach_comparison = "delta",
    exp_central_1 = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    exp_central_2 = c(50, 55, 60, 65, 75), # Fake values
    population_1 = sum(c(387500, 286000, 191800, 72200, 7700)),
    population_2 = sum(c(387500, 286000, 191800, 72200, 7700)),
    prop_pop_exp_1 = c(387500, 286000, 191800, 72200, 7700)/sum(c(387500, 286000, 191800, 72200, 7700)), # Values as example provided by NIPH
    prop_pop_exp_2 = c(387500, 286000, 191800, 72200, 7700)/sum(c(387500, 286000, 191800, 72200, 7700)), # Fake values
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022)
    )

# View(comparison_singlebhd_ar_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta ,
               result_vector_alternative = c(62531)) # Result on 23 May 2024

comparison_singlebhd_ar_delta_geo <-
  healthiar::compare_health(
    approach_risk = "absolute_risk",
    approach_comparison = "delta",
    exp_central_1 = list(c(57.5, 62.5, 67.5, 72.5, 77.5), c(57, 62, 67, 72, 77)),# Fake values
    exp_central_2 = list(c(50, 55, 60, 65, 75), c(50.5, 55.5, 60.5, 65.5, 75.5)), # Fake values
    population_1 = list(945200, 929800),
    population_2 = list(945200, 929800),
    prop_pop_exp_1 = list(c(387500, 286000, 191800, 72200, 7700)/945200, 
                          c(380000, 280000, 190800, 72000, 7000)/929800), # Fake values
    prop_pop_exp_2 = list(c(387500, 286000, 191800, 72200, 7700)/945200, 
                          c(380000, 280000, 190800, 72000, 7000)/929800), # Fake values
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022),
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_singlebhd_ar_delta_geo)

check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta_geo ,
               result_vector_alternative = 115869) # Result on 19 June 2024

```

```{r comparison yld singlebhd_rr}
# DELTA
# Test delta comparison function with fake values
comparison_yld_singlebhd_rr_delta <-
  healthiar::compare_yld(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# View(comparison_yld_singlebhd_rr_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta ,
               result_vector_alternative = c(387, 205, 564)) # Result on 16 May 2024

# Additionally check that the first scenario produces the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["health_main"]]$impact_rounded) 

# Iteration
comparison_yld_singlebhd_rr_delta_geo <-
  healthiar::compare_yld(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yld_singlebhd_rr_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(591, 313, 861)) # Result on 26 June 2024


#PIF
# Test pif comparison function with fake values
comparison_yld_singlebhd_rr_pif <-
  healthiar::compare_yld(
    approach_comparison = "pif",
    exp_central_1 = 8.85,  
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# View(comparison_yld_singlebhd_rr_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif ,
               result_vector_alternative = c(391,206,573)) # Result on 16 May 2024

# Additionally check that the first scenario produces the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["health_main"]]$impact_rounded) 

# Iteration
comparison_yld_singlebhd_rr_pif_geo <-
  healthiar::compare_yld(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yld_singlebhd_rr_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(599, 315, 878)) # Result on 20 June 2024
```

### Lifetable

```{r comparison deaths lifetable, warning=TRUE}

# DELTA

comparison_deaths_lifetable_delta <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# View(comparison_deaths_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta,
               # result_vector_alternative = c(1922,1017,2801)) # Result on 16 May 2024
               result_vector_alternative = c(1915, 1013, 2795 )) # Result on 20 August 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact_rounded)  

# Iteration
comparison_deaths_lifetable_delta_geo <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2= airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_deaths_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta_geo ,
               # result_vector_alternative = c(2935, 1553, 4279)) # Result on 09 July 2024
               result_vector_alternative = c(2925, 1546, 4269)) # Result on 20 August 2024


# Additionally check that it produces the first scenario produce the same results as above
# comparison_deaths_lifetable_delta_geo[["health_detailed"]][["scenario_1"]][["health_detailed"]][["raw"]] |>  dplyr::filter(., geo_id_disaggregated %in% "a") |> select(., impact)  |> pull(.) == bestcost_pm_deaths_lifetable_geluft[["health_main"]]$impact 
round(comparison_deaths_lifetable_delta_geo[["health_detailed"]][["scenario_1"]][["health_detailed"]][["raw"]] |>  
        dplyr::filter(geo_id_disaggregated %in% "a") |> 
        select(impact)  |> 
        pull(), digits = 0) == 
  round(bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact)
# Absolute differences
abs(comparison_deaths_lifetable_delta_geo[["health_detailed"]][["scenario_1"]][["health_detailed"]][["raw"]] |>  
      dplyr::filter(geo_id_disaggregated %in% "a") |> select(impact)  |> pull() 
    - bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact)
# Absolute differences are negligeable (< 0.01, or < 0.0001%)
      

# PIF
comparison_deaths_lifetable_pif  <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    approach_exposure_1 = "single_year",
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    approach_exposure_2 = "single_year",
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    min_age = 20)

# View(comparison_deaths_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif ,
               # result_vector_alternative = c(1943,1023,2847)) # Result on 16 May 2024
               result_vector_alternative = c(1935, 1018, 2837 )) # Result on 20 August 2024

# Additionally check that scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif[["health_detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact_rounded)  # AirQ+ result


# Iteration
comparison_deaths_lifetable_pif_geo <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_deaths_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif_geo ,
               # result_vector_alternative = c(2974, 1563, 4362)) # Result on 09 July 2024
               result_vector_alternative = c(2961, 1556, 4346)) # Result on 20 AUgust 2024
```

```{r comparison YLL lifetable}

# DELTA 
comparison_yll_lifetable_delta  <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    approach_newborns_1 = "without_newborns",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019,
    approach_exposure_2 = "single_year",
    approach_newborns_2 = "without_newborns",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# View(comparison_yll_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta,
               # result_vector_alternative = c(20421,10806,29763)) # Results on 16 May 2024
               result_vector_alternative = c(21644, 11340, 31860)) # Results on 20 August 2024


# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["health_main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_exposure_single_year_lifetable_geluft[["health_main"]]$impact_rounded) # AirQ+ results

# Iteration
comparison_yll_lifetable_delta_geo <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yll_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta_geo ,
               # result_vector_alternative = c(31190, 16500, 45472)) # Results on 08 July 2024
               result_vector_alternative = c(33041, 17309, 48639)) # Results on 20 August 2024

# PIF
comparison_yll_lifetable_pif <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20)

# View(comparison_yll_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               # result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024
               result_vector_alternative = c(21698, 11354, 31978 )) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif[["health_detailed"]][["scenario_1"]],
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["health_main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_exposure_single_year_lifetable_geluft[["health_main"]]$impact_rounded)

# Iteration
comparison_yll_lifetable_pif_geo <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yll_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif_geo ,
               # result_vector_alternative = c(31601, 16613, 46359)) # Result on 08 July 2024
               result_vector_alternative = c(33137, 17335, 48851)) # Result on 20 August 2024
```

```{r comparison YLD lifetable}

# DELTA
comparison_yld_lifetable_delta  <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta ,
               # result_vector_alternative = c(20421, 10806, 29763)) # Result on 16 May 2024
               result_vector_alternative = c(21644, 11340, 31860)) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["health_main"]]$impact_rounded) 

# Iteration
comparison_yld_lifetable_delta_geo <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta_geo ,
               # result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024
               result_vector_alternative = c(33041, 17309, 48639)) # Result on 20 August 2024

# PIF
comparison_yld_lifetable_pif <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif ,
               # result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024
               result_vector_alternative = c(21698, 11354, 31978)) # Result on 20 August 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif[["health_detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["health_main"]]$impact_rounded)

# Iteration
comparison_yld_lifetable_pif_geo <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif_geo ,
               # result_vector_alternative = c(31601, 16613, 46359)) # Result on 26 June 2024
               result_vector_alternative = c(33137, 17335, 48851)) # Result on 20 August 2024

```

```{r comparison DALY lifetable}

# DELTA
comparison_daly_lifetable_delta  <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5, # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta ,
               # result_vector_alternative = c(20421*2,10806*2,29763*2)) # Result on 16 May 2024
               result_vector_alternative = c(43288, 22679, 63720)) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["health_main"]]$impact_rounded) 

# Iteration
comparison_daly_lifetable_delta_geo <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta_geo ,
               # result_vector_alternative = c(31190*2, 16500*2, 45472*2)) # Result on 08 July 2024
               result_vector_alternative = c(66082, 34618, 97279)) # Result on 20 August 2024

# PIF
comparison_daly_lifetable_pif <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif ,
               # result_vector_alternative = c(20650*2, 10870*2, 30257*2)) # Result on 16 May 2024
               result_vector_alternative = c(43396, 22708, 63957 )) # Result on 20 August 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif[["health_detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["health_main"]]$impact_rounded)

# Iteration
comparison_daly_lifetable_pif_geo <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    rr_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_disaggregated = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif_geo ,
               # result_vector_alternative = c(31601*2, 16613*2, 46359*2)) # Result on 26 June 2024
               result_vector_alternative = c(66275, 34671, 97702)) # Result on 20 August 2024

```

# Cost

```{r Monetize a simple case}
# Monetize only with valuation
bestcost_pm_copd_costs <- 
  healthiar::include_monetization(output_healthiar = bestcost_pm_copd, 
                                  valuation = 1000)
check_general(bestcost_pm_copd_costs[["monetization_main"]]$monetized_impact_rounded,
              round(bestcost_pm_copd[["health_main"]]$impact * 1000))


# Direct discounting
## Monetize with all arguments (including discount)
bestcost_pm_copd_costs_discount <- 
  healthiar::include_monetization(
    approach_discount = "direct",
    output_healthiar = bestcost_pm_copd,
    discount_shape = "exponential",
    discount_rate = 0.03,
    discount_years = 5,
    valuation = 20,
    discount_overtime = "last_year")

check_general(bestcost_pm_copd_costs_discount[["monetization_main"]]$monetized_impact_rounded,
              c(60416, 23343, 94436)) # Result on 9 Jan 2025

## Monetize with impact (without output of attribute)
bestcost_pm_copd_cost_discount_single_value <- 
  healthiar::include_monetization(
    approach_discount = "direct",
    impact = 2E4, 
    discount_shape = "exponential",
    discount_rate = 0.03,
    discount_years = 20,
    valuation = 1)

check_general(bestcost_pm_copd_cost_discount_single_value[["monetization_main"]]$monetized_impact_rounded,
              14877)
## According to ChatGPT, the result should be 14877. 5 Dec 2024



## Discounting only one specific year
bestcost_pm_copd_cost_discount_single_value <-
  healthiar::include_monetization(
    approach_discount = "direct",
    impact = 50,
    discount_shape = "exponential",
    discount_rate = 0.03,
    discount_years = 5,
    discount_overtime = "last_year",
    valuation = 20)

check_general(bestcost_pm_copd_cost_discount_single_value[["monetization_main"]]$monetized_impact_rounded,
              863) # As indicated by University of Port in Excel file



# Indirect approach. 
## valuation=1 to compare results with only discounting
bestcost_pm_yll_lifetable_geluft_indirect <- 
  healthiar::include_monetization(
    approach_discount = "indirect",
    output_healthiar = bestcost_pm_yll_exposure_single_year_lifetable_geluft, 
    discount_shape = "exponential",
    discount_rate = 0.01,
    valuation = 1)

check_general(bestcost_pm_yll_lifetable_geluft_discount[["monetization_main"]]$monetized_impact_rounded,
              c(26493, 13877, 39006))
# Result on 13 Dec 2025. Same result as discounting in attribute() (deprecated).

```

```{r only discounting}

# Discounting without valuation
bestcost_pm_copd_discount <- 
  healthiar::include_discount(
    approach_discount = "direct",
    impact = 2E4,
    discount_shape = "exponential",
    discount_rate = 0.03,
    discount_years = 20)

check_general(bestcost_pm_copd_discount[["monetization_main"]]$monetized_impact_rounded,
              14877)# Results on 2025-01-15

```


```{r with inflation}

bestcost_inflation_attribute_result <- 
  healthiar::include_monetization(
    approach_discount = "direct",
    output_healthiar = bestcost_pm_copd,
    discount_shape = "exponential",
    discount_rate = 0.05,
    discount_years = 5,
    inflation = 0.08,
    valuation = 1E3)

## Test helper_extract_main_monetization_results() fct
bestcost_inflation_attribute_result_main <- healthiar::helper_extract_main_monetization_results(bestcost_inflation_attribute_result) 

# Discounting without valuation a non-attribute result  
bestcost_inflation <- 
  healthiar::include_monetization(
    approach_discount = "direct",
    impact = 5,
    discount_shape = "exponential",
    discount_rate = 0.05,
    discount_years = 5,
    inflation = 0.08,
    valuation = 1E3)

check_general(bestcost_inflation[["monetization_main"]]$monetized_impact_rounded,
              5445)# Results on 2025-03-04 from the sheet of Uni Porto

## Test helper_extract_main_monetization_results() fct
bestcost_inflation_main <- healthiar::helper_extract_main_monetization_results(bestcost_inflation) # Throws error
```

```{r cba}

## Discounting only one specific year (attr input)
bestcost_pm_copd_cba_attr_input <-
  healthiar::include_cba(
    output_healthiar = bestcost_pm_copd,
    approach_discount = "direct",
    valuation = 20,
    cost = 100,
    discount_shape = "exponential",
    discount_rate_benefit = 0.03,
    discount_rate_cost = 0.03,
    discount_years_benefit = 5,
    discount_years_cost = 5,
    discount_overtime = "last_year")
check_general(bestcost_pm_copd_cba_attr_input[["cba_main"]]$benefit_minus_cost_rounded,
              c(60330,23257,94350)) # Results on 2025-03-06; no comparison study

## Test helper_extract_main_cba_results fct
bestcost_pm_copd_cba_attr_input_main <- 
  healthiar::helper_extract_main_cba_results(bestcost_pm_copd_cba_attr_input)

## Discounting only one specific year (raw input)
bestcost_pm_copd_cba_raw_input <-
  healthiar::include_cba(
    approach_discount = "direct",
    positive_impact = 50,
    valuation = 20,
    cost = 100,
    discount_shape = "exponential",
    discount_rate_benefit = 0.03,
    discount_rate_cost = 0.03,
    discount_years_benefit = 5,
    discount_years_cost = 5,
    discount_overtime = "last_year")
check_general(bestcost_pm_copd_cba_raw_input[["cba_main"]]$benefit_minus_cost_rounded,
              776) # As indicated by University of Port in Excel file

## Test helper_extract_main_cba_results fct
bestcost_pm_copd_cba_main <- 
  healthiar::helper_extract_main_cba_results(bestcost_pm_copd_cba_raw_input)

## Discounting only one specific year
bestcost_pm_copd_cba_output <-
  healthiar::include_cba(
    approach_discount = "direct",
    output_healthiar = bestcost_pm_copd,
    valuation = 20,
    cost = 100,
    discount_shape = "exponential",
    discount_rate_benefit = 0.03,
    discount_rate_cost = 0.03,
    discount_years_benefit = 5,
    discount_years_cost = 5,
    discount_overtime = "last_year")
check_general(bestcost_pm_copd_cba_output[["cba_main"]]$benefit_minus_cost_rounded,
              c(60416, 23343, 94436) - 86) # As indicated by University of Porto in Excel file




```

# Test prepare function

```{r prepare_exposure_data, eval=FALSE, include=FALSE}

## To be added
# test <- healthiar::prepare_exposure_data()
```

# Other

```{r Demo unit meeting, eval=FALSE, include=FALSE}

## Unit meeting demo
# data <- airqplus_pm_copd |> 
#   mutate(prevalence = incidents_per_100_000_per_year/1E5*population_at_risk)

#3 Calculate COPD cases attributable to PM exposure
# results_pm_copd <-
#   healthiar::attribute_health(
#     exp_central = data$mean_concentration,                      # 8.85
#     cutoff_central = data$cut_off_value,                        # 5
#     bhd_central = data$prevalence,                              # 30747
#     bhd_lower = data$prevalence - 1000,                         # 29747
#     bhd_upper = data$prevalence + 1000,                         # 31747
#     rr_central = data$relative_risk,                            # 1.36
#     rr_lower = data$relative_risk_lower,                        # 1.124
#     rr_upper = data$relative_risk_upper,                        # 1.664
#     rr_increment = 10,                                           
#     erf_shape = "log_linear", 
#     info = "pm_copd_assessment_1")

## Check results
# View(results_pm_copd)
# View(results_pm_copd$main)
# View(results_pm_copd$detailed$raw)

## Now with population
# results_pm_copd_pop <-
  # healthiar::attribute(
  #   exp_central = data$mean_concentration,                      # 8.85
  #   cutoff_central = data$cut_off_value,                        # 5
  #   bhd_central = data$prevalence,                              # 30747
  #   bhd_lower = data$prevalence - 1000,                         # 29747
  #   bhd_upper = data$prevalence + 1000,                         # 31747
  #   rr_central = data$relative_risk,                            # 1.36
  #   rr_lower = data$relative_risk_lower,                        # 1.124
  #   rr_upper = data$relative_risk_upper,                        # 1.664
  #   rr_increment = 10,                                           
  #   erf_shape = "log_linear", 
  #   info = "pm_copd_assessment_1",
  #   population = 1E6)
```

```{r Screenshot for poster, eval=FALSE, include=FALSE}

# health_impact <- attribute(
#     exp_central = 12.3,
#     bhd_central = 15000,
#     rr_central = 1.04,
#     rr_lower = 1.02,
#     rr_upper = 1.06,
#     cutoff_central = 5,
#     erf_shape = "log_linear",
#     info = "scenario_1")
# 
# health_impact <- attribute(
#     exposure = 12.3,
#     baseline_health_data = 15000,
#     rr_central = 1.04,
#     cutoff = 5,
#     erf_shape = "log_linear",
#     info = "PM2.5_scenario_1")

```

```{r Illustration integrate compare() in attribute()}

# Benefit of this: compare the two conceptionally different approaches
 
# case1 <- attribute(approach= cutoff in exposure)

# case2 <- attribute(approach = delta approach/cutoff in ERF)

# difference impact <- case1[[impact]] - case2[[impact]]
```
