---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---
# Goal
Test the functions of the bestcost package comparing the results with results from other tools or assessments


# Load packages and data


The R script required the loading of certain R packages. 
```{r Load packages, include=FALSE}
# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(zoo)

# to set colors in console messages (checking)
library(crayon)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)


```


```{r load bestcost package}
# Load package (either current version or installed version)
devtools::load_all(export_all = FALSE)
#library(bestcost)
```


```{r Alternative 1 to load bestcost: Install own package from github, eval=FALSE, include=FALSE}
# Install own package from github as suggested here: https://stackoverflow.com/a/71846333/6104907
if(!"bestcost" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT if prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/bestcost",
                           ref = "HEAD", # Branch name (by default "HEAD") as a string
                           force = TRUE)
}
library(bestcost)
```



```{r Alternative 2 to load bestcost: load zip from local source, eval=FALSE, include=FALSE}
detach("package:bestcost", unload = TRUE) # detach bestcost
devtools::build(binary = TRUE, path = "../testing/input/") # Save current state of package as .zip file (e.g. to directly test changes in functions)
install.packages("../testing/input/bestcost_0.0.0.1.zip", repos=NULL, type='source') # Install package from source
library(bestcost)
```


Load the Rdata file that contains all variables needed to run this script.
```{r load data }
load("../testing/input/data/input_data_for_testing_Rpackage.RData")
```



# Calculate health impacts

## Attributable health impact

### Single baseline health data

```{r single exposure value}
# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central,
                estimated_number_of_attributable_cases_lower,
                estimated_number_of_attributable_cases_upper)%>%
  unlist()


check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```


```{r multiple single exposure value, eval=FALSE, include=FALSE}
# Assess attributable cases for multiple uncertainties at the same time
# i.e. rr, bhd and exp
bestcost_pm_copd_multiple <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = 25000,
    bhd_upper = 35000,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))


# Assess iteration geographical sections keeping the multiple uncertainties
system.time(bestcost_pm_copd_geo <-
  bestcost::attribute_health(
    exp_central = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    cutoff = 5,   
    bhd_central = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info = "PM2.5_copd"))

```


```{r single exposure value and relative risk}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd_1rr <-
  bestcost::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_1rr_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central)%>%
  unlist()


check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)


```


```{r exposure distribution}

# Extract rows that contain input data (others may contain results)
niph_noise_ihd_input <- 
  niph_noise_ihd_excel %>%
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ihd_result <- 
  niph_noise_ihd_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(daly)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  bestcost::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))


check_bestcost(result_list_bestcost = bestcost_noise_ihd_expDist,
               result_vector_alternative = niph_noise_ihd_result)

# Obtain attributable cases using the bestcost package
# for multiple geo_sections
bestcost_noise_ihd_expDist_geo <- 
  bestcost::attribute_health(
    exp_central = list(runif_with_seed(5,8,10,1), 
                       runif_with_seed(5,8,10,2), 
                       runif_with_seed(5,8,10,3)),
    cutoff = 5,
    prop_pop_exp = list(runif_with_seed(5,0.1,1,1),
                        runif_with_seed(5,0.1,1,2), 
                        runif_with_seed(5,0.1,1,3)),
    bhd_central = list(runif_with_seed(3,1E4,1E5,1)),
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    geo_id_raw = 1:3,
    geo_id_aggregated = rep("ch", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

                                               

```


```{r absolute risk}

# Extract rows that contain input data (others may contain results)
niph_noise_ha_input <- 
  niph_noise_ha_excel %>%
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ha_result <- 
  niph_noise_ha_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(number)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ha_ar <- 
  bestcost::attribute_health_ar(
    exp_central = niph_noise_ha_input$exposure_mean,
    pop_exp = niph_noise_ha_input$population_exposed_total, 
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result)


# Obtain attributable cases using the bestcost package and input data from niph
# for multiple geo_sections
bestcost_noise_ha_ar_geo <- 
  bestcost::attribute_health_ar(
    exp_central = list(runif_with_seed(5,8,10,1), 
                          runif_with_seed(5,8,10,2), 
                          runif_with_seed(5,8,10,3)),
    pop_exp = list(runif_with_seed(5,5E3,1E4,1), 
                   runif_with_seed(5,5E3,1E4,2), 
                   runif_with_seed(5,5E3,1E4,3)), 
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_raw = 1:3,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r morbidity yld lifetable with single relative risk}

bestcost_pm_yld_singlebhd  <- 
  bestcost::attribute_yld_from_prevalence(
    exp_central = 8.85, 
    cutoff = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd ,
               result_vector_alternative = c(525, 277, 768)) # Result on 16 May 2024


```


### Life table

#### Probability of dying

```{r Probability of dying}

# Remove years over 40 
# because we are going to compare with results up to 39 years old
airqplus_prob_dying_age0to39_multipleYear <- 
  airqplus_deaths_pop_multipleYear%>%
  dplyr::filter(To<40)

# Results from the AirQ+ manual (to be compared with bestcost results)
airqplus_prob_dying_age0to39_singleYear <-
  airqplus_deaths_pop_singleYear%>%
  dplyr::filter(To<40)%>%
  dplyr::mutate(qx = as.numeric(qx))

# Use bestcost function
bestcost_prob_dying <- 
  bestcost::get_prob_dying_by_single_age(
    first_age_pop = first(airqplus_prob_dying_age0to39_multipleYear$From),
    last_age_pop = last(airqplus_prob_dying_age0to39_multipleYear$To),
    interval_age_pop = first(airqplus_prob_dying_age0to39_multipleYear$To) - first(airqplus_prob_dying_age0to39_multipleYear$From)+1,
    population_midyear = airqplus_prob_dying_age0to39_multipleYear$mi,
    deaths = airqplus_prob_dying_age0to39_multipleYear$di,
    fraction_of_year_lived = 0.5
  )


# Compare and show message with colors

if(all((bestcost_prob_dying$prob_dying - 
        airqplus_prob_dying_age0to39_singleYear$qx) < 0.002)){
  cat(paste(crayon::yellow("Bestcost and alternative source with similar results.")))
} else{
    cat(paste(crayon::red("Attention! Check! Bestcost and alternative source with very different results.")))}
# There is a very small deviation 
# due to different rounding 
# (bestcost does not round, while airqplus does)
```


#### Premature deaths

```{r premature deaths with lifetable}
# First obtain probability of dying 
# for total and natural deaths and for male and female separately
# (AirQ+ does not use probability of dying as input data but bestcost does)
# (AirQ+ only uses natural mortality --> different methodological approach)

prob_dying <- list()

for(d in c("natural", "total")){
  for(s in c("male", "female")){
   prob_dying[[d]][[s]] <-
     bestcost::get_prob_dying_by_single_age(
      first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      interval_age_pop = 
        unique(airqplus_pm_deaths_yll[["pop"]]$age_from... - 
                 airqplus_pm_deaths_yll[["pop"]]$age_from...) + 1,
      population_midyear = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("midyear_population_", s)]),
      deaths = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("number_of_deaths_", s)]))
  }
}

# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case
# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case

bestcost_pm_deaths_lifetable_airqplus <-
  bestcost::attribute_deaths_from_lifetable(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)


check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus,
               result_vector_alternative = c(2600.9, 1371, 3804))
```



```{r premature deaths with lifetable}
# Now with input data from the Swiss project GeLuft


bestcost_pm_deaths_lifetable_geluft <- 
    bestcost::attribute_deaths_from_lifetable(
    exp_central = input_data_mortality$exp[2], # PM2.5=8.85 exp in CH in 2019
    cutoff = input_data_mortality$cutoff[2],   # PM2.5=5,i.e. WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper = input_data_mortality[2,"rr_upper"],
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_geluft ,
               result_vector_alternative = c(2610, 1378, 3815))



```



```{r premature deaths with lifetable and exposure distribution}

# Calculate premature deaths using bestcost function
bestcost_pm_deaths_lifetable_expDistribution <- 
    bestcost::attribute_deaths_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
      rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
      rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
      rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = 20)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_geluft ,
               result_vector_alternative = c(2610, 1378, 3815)) # Result on 16 May 2024



```


#### Years of life lost

```{r yll with lifetable GeLuft approach}

# Calculate years of life lost using bestcost function
# and input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus_org <-
  bestcost::attribute_yll_from_lifetable(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10,
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year,
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# Check results
# They are extremely different. The methodology of airq+ is very different to other studies
# AirQ+ considers that the increase/decrease of exposure happens 100 years,
# while other studies (e.g. GeLuft) look at the impact over 100 years of a one-year exposure.

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus_org,
               result_vector_alternative =
                 c(airqplus_pm_deaths_yll[["output"]]$value_central_allgenders_yll_over_100_years_age_20_99,
                   airqplus_pm_deaths_yll[["output"]]$value_lower_allgenders_yll_over_100_years_age_20_99,
                   airqplus_pm_deaths_yll[["output"]]$value_upper_allgenders_yll_over_100_years_age_20_99))

# Calculate years of life lost using new bestcost function
# and input data from an AirQ+ case

# Now with input data from the Swiss project GeLuft
bestcost_pm_yll_lifetable_geluft <- 
  bestcost::attribute_yll_from_lifetable(
    exp_central = input_data_mortality$exp[2], #exp CH 2019
    prop_pop_exp = 1,
    cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis = 2019, 
    corrected_discount_rate = 0,
    info = input_data_mortality$pollutant[2], 
    min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_geluft,
               result_vector_alternative = c(27742, 14641, 40542))

```

```{r probability of dying}
prob_dying <- list()

for(d in c("natural", "total")){
  for(s in c("male", "female")){
   prob_dying[[d]][[s]] <-
     bestcost::get_prob_dying_by_single_age(
      first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      interval_age_pop = 
        unique(airqplus_pm_deaths_yll[["pop"]]$age_from... - 
                 airqplus_pm_deaths_yll[["pop"]]$age_from...) + 1,
      population_midyear = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("midyear_population_", s)]),
      deaths = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("number_of_deaths_", s)]))
  }
}

# Compare natural survival probability (note: first run chunk below): 
# - computed by function bestcost::get_prob_dying_by_single_age()
# - computed during call to attribute_yll_from_lifetable (airqplus approach)
# table(prob_dying[["natural"]][["male"]]$prob_surviving == bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["lifetable_with_pop_nest"]][[1]]$prob_survival)
# Exactly the same
```

```{r yll from lifetable airqplus approach}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus <-
  bestcost::attribute_yll_from_lifetable(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# Compare sex-specific results
yll_male <- bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["lifeyears_nest"]][[1]] %>% 
  filter(year == 2019) %>%  select(impact) %>%  as_vector() %>%  unname(.)
yll_female <- bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["lifeyears_nest"]][[2]] %>% 
  filter(year == 2019) %>% select(impact) %>% as_vector() %>%  unname(.)
print("YLL male 2019 identical:") ; round(yll_male) == round(624.43) # Value from AirQ+ output Excel
print("YLL female 2019 identical:") ; round(yll_female) == round(675.25) # Value from AirQ+ output Excel

# Compare total YLL (YLL males + YLL females)
airqplus_yll_difference <- read.xlsx("../testing/Replication_AirQ+/airqplus_deaths_yll_lifetable_adults.xlsx", sheet = "yll_difference", startRow = 1, rows = c(1:101))
yll_total_rounded <- round(bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["pop_impact_nest"]][[3]] %>% select(-age_end))

print("2019 sum total YLLs (unrouded) identical:") # Value from AirQ+ output Excel
1300.43 == round(sum(bestcost_pm_yll_lifetable_airqplus[["detailed"]][["interim"]][["pop_impact_nest"]][[3]]$population_2019), digits = 2)
print("2019 total YLLs identical:")
table(airqplus_yll_difference$`2019` == yll_total_rounded$population_2019)
print("2020 total YLLs identical:")
table(airqplus_yll_difference$`2020` == yll_total_rounded$population_2020)
print("2020 absolute difference in YLLs:")
print(abs(airqplus_yll_difference$`2020` - yll_total_rounded$population_2020))

print("2021 absolute difference in YLLs:")
print(abs(airqplus_yll_difference$`2021` - yll_total_rounded$population_2021))

print("2050 absolute difference in YLLs")
print(abs(airqplus_yll_difference$`2050` - yll_total_rounded$population_2050))
# Max difference constant at 1 --> rounding error
```


```{r yll lifetable with single relative risk}
# Only one relative risk estimate (central estimate)

# Calculate years of life lost using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yll_lifetable_1rr_geluft <- 
    bestcost::attribute_yll_from_lifetable(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff = input_data_mortality$cutoff[2], 
      rr_central = input_data_mortality[2,"rr_central"], 
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_1rr_geluft,
               result_vector_alternative = c(27742))
```


```{r yll lifetable with exposure distribution}

# Calculate years of life lost using bestcost function
# with exposure distribution (instead of population-weighted mean)

bestcost_pm_yll_lifetable_expDistribution_geluft <- 
    bestcost::attribute_yll_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      erf_increment = 10,
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_expDistribution_geluft ,
               result_vector_alternative = c(30931, 16337, 45166)) # Result on 16 May 2024

```

#### Years lived with disability

```{r morbidity yld lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yld_lifetable_geluft  <- 
  attribute_yld_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    # exp_central = c(8, 9, 10), # Fake data. Deactivate to test exposure distribution.
    prop_pop_exp = 1,
    # prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data. Deactivate to test exposure distribution.
    cutoff = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    corrected_discount_rate = 0,
    duration = 100, 
    disability_weight = 1
  )

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
check_bestcost(result_list_bestcost = bestcost_pm_yld_lifetable_geluft,
               result_vector_alternative = c(27742, 14641, 40542))

```

## Comparison

### Single bhd

```{r comparison singlebhd_rr}
# Test delta comparison function with fake values
# DELTA

comparison_singlebhd_rr_delta <-
  bestcost::compare_health(
    comparison_method = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta ,
               result_vector_alternative = c(774, 409, 1127)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_delta_geo <-
  bestcost::compare_health(
    comparison_method = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(1100, 582, 1603)) # Result on 26 June 2024

#PIF
# Test pif comparison function with fake values
comparison_singlebhd_rr_pif <-
  bestcost::compare(
    comparison_method = "pif",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif ,
               result_vector_alternative = c(782, 412, 1146)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_pif_geo <-
  bestcost::compare_health(
    comparison_method = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(1114, 586, 1634)) # Result on 19 June 2024
```


```{r comparison singlebhd_rr geo iteration, eval=FALSE, include=FALSE}
# Assess iteration in many geographical areas (geo_id) keeping the multiple uncertainties
comparison_singlebhd_rr_geo <-
  bestcost::compare_health(
    comparison_method = "delta",
    exp_central_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    exp_central_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)),
    exp_lower_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)-0.1),
    exp_upper_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)+0.1),
    cutoff = 5,   
    bhd_central_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_central_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")
```


```{r comparison ar}

# Test delta comparison function with fake values
# No PIF option in ar
comparison_singlebhd_ar_delta <-
  bestcost::compare_health_ar(
    comparison_method = "delta",
    exp_central_1 = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    exp_central_2 = c(50, 55, 60, 65, 75), # Fake values
    pop_exp_1 = c(387500, 286000, 191800, 72200, 7700), # Values as example provided by NIPH
    pop_exp_2 = c(387500, 286000, 191800, 72200, 7700), # Fake values
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta ,
               result_vector_alternative = c(62531)) # Result on 23 May 2024

comparison_singlebhd_ar_delta_geo <-
  bestcost::compare_health_ar(
    comparison_method = "delta",
    exp_central_1 = list(c(57.5, 62.5, 67.5, 72.5, 77.5), c(57, 62, 67, 72, 77)),# Fake values
    exp_central_2 = list(c(50, 55, 60, 65, 75), c(50.5, 55.5, 60.5, 65.5, 75.5)), # Fake values
    pop_exp_1 = list(c(387500, 286000, 191800, 72200, 7700), c(380000, 280000, 190800, 72000, 7000)), # Fake values
    pop_exp_2 = list(c(387500, 286000, 191800, 72200, 7700), c(380000, 280000, 190800, 72000, 7000)), # Fake values
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022),
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))


check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta_geo ,
               result_vector_alternative = 115869) # Result on 19 June 2024

```

```{r comparison yld singlebhd_rr}
# DELTA
# Test delta comparison function with fake values
comparison_yld_singlebhd_rr_delta <-
  bestcost::compare_yld_from_prevalence(
    comparison_method = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta ,
               result_vector_alternative = c(387, 205, 564)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["main"]]$impact_rounded) 


# Iteration
comparison_yld_singlebhd_rr_delta_geo <-
  bestcost::compare_yld_from_prevalence(
    comparison_method = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(591, 313, 861)) # Result on 26 June 2024


#PIF
# Test pif comparison function with fake values
comparison_yld_singlebhd_rr_pif <-
  bestcost::compare_yld_from_prevalence(
    comparison_method = "pif",
    exp_central_1 = 8.85,  
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")



# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif ,
               result_vector_alternative = c(391,206,573)) # Result on 16 May 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["main"]]$impact_rounded) 


# Iteration
comparison_yld_singlebhd_rr_pif_geo <-
  bestcost::compare_yld_from_prevalence(
    comparison_method = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(599, 315, 878)) # Result on 20 June 2024


```

### Lifetable
```{r comparison deaths lifetable}

# DELTA

comparison_deaths_lifetable_delta <-
  bestcost::compare_deaths_from_lifetable(
    comparison_method = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta ,
               result_vector_alternative = c(1922,1017,2801)) # Result on 16 May 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_deaths_lifetable_geluft[["main"]]$impact_rounded) 

# Iteration
comparison_deaths_lifetable_delta_geo <-
  bestcost::compare_deaths_from_lifetable(
    comparison_method = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta_geo ,
               result_vector_alternative = c(2935, 1553, 4279)) # Result on 09 July 2024

# Additionally check that it produces the first scenario produce the same results as above
comparison_deaths_lifetable_delta_geo[["detailed"]][["scenario_1"]][["detailed"]][["raw"]] %>%  dplyr::filter(., geo_id_raw %in% "a") %>% select(., impact)  %>% pull(.) == bestcost_pm_deaths_lifetable_geluft[["main"]]$impact 


# PIF

comparison_deaths_lifetable_pif  <-
  bestcost::compare_deaths_from_lifetable(
    comparison_method = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    min_age = 20)



# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif ,
               result_vector_alternative = c(1943,1023,2847)) # Result on 16 May 2024

# Additionally check that scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_deaths_lifetable_geluft[["main"]]$impact_rounded) 


# Iteration
comparison_deaths_lifetable_pif_geo <-
  bestcost::compare_deaths_from_lifetable(
    comparison_method = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif_geo ,
               result_vector_alternative = c(2974, 1563, 4362)) # Result on 09 July 2024


```



```{r comparison yll lifetable}

# DELTA 
comparison_yll_lifetable_delta  <-
  bestcost::compare_yll_from_lifetable(
    comparison_method = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta ,
               result_vector_alternative = c(20421,10806,29763)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["main"]]$impact_rounded) 


# Iteration
comparison_yll_lifetable_delta_geo <-
  bestcost::compare_yll_from_lifetable(
    comparison_method = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta_geo ,
               result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024

# PIF
comparison_yll_lifetable_pif <-
  bestcost::compare_yll_from_lifetable(
    comparison_method = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20)


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               result_vector_alternative = c(20650,10870,30257)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["main"]]$impact_rounded)


# Iteration
comparison_yll_lifetable_pif_geo <-
  bestcost::compare_yll_from_lifetable(
    comparison_method = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif_geo ,
               result_vector_alternative = c(31601, 16613, 46359)) # Result on 08 July 2024

```





```{r comparison yld lifetable}

# DELTA
 
comparison_yld_lifetable_delta  <-
  bestcost::compare_yld_from_lifetable(
    comparison_method = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration = 100,
    disability_weight = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta ,
               result_vector_alternative = c(20421,10806,29763)) # Result on 16 May 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["main"]]$impact_rounded) 



# Iteration
comparison_yld_lifetable_delta_geo <-
  bestcost::compare_yll_from_lifetable(
    comparison_method = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta_geo ,
               result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024


# PIF
comparison_yld_lifetable_pif <-
  bestcost::compare_yld_from_lifetable(
    comparison_method = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration = 100,
    disability_weight = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif ,
               result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["main"]]$impact_rounded)




# Iteration
comparison_yld_lifetable_pif_geo <-
  bestcost::compare_yll_from_lifetable(
    comparison_method = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif_geo ,
               result_vector_alternative = c(31601, 16613, 46359)) # Result on 26 June 2024

```


# Export 

```{r eval=FALSE, include=FALSE}
# write.csv2(lifetable_airqplus,
#             "../testing/output/lifetable_airqplus_2019_ch.csv", 
#             row.names = FALSE)
```
