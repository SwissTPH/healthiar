---
title: "Hello, I'm healthiar!"
subtitle: "R package workshop for BEST-COST"
author:
  - name:
      given: Axel Luyten &
      family: Alberto Castro
    affiliations:
      - name: Swiss TPH
    orcid: 0000-0002-7005-5889
    email: axel.luyten@swisstph.ch & alberto.castrofernandez@swisstph.ch
date: 2025-03-24 # last-modified
editor: source
execute: 
  eval: true
  echo: true
  warning: false
freeze: auto
format:
  revealjs:
    # code-line-numbers: true # Doesn't work; probably works for html format
    css: custom_style.css
    # code-tools: # Test at later point what this does
      # source: https://github.com/best-cost/best-cost_WPs/tree/master
    # code-fold: true # Folds code chunk in the HTML prez
    incremental: true
    transition: none # alts: fade, none, slide
    transition-speed: default
    # table-of-contents: true
    # toc-depth: 1
    logo: images/combo_logo_stph_bc.png
    # footer: 'healthiar WP5 workshop 1'
    smaller: true # If you set {.smaller} after the slide title, reduces font automatically so content fits on slide
    scrollable: true # If you set {.scrollable} after the slide title, let's you scroll on the slide
    template-partials:
      - title-slide.html
    title-slide-attributes:
      data-background-image: images/combo_title_stph_bc.png
      data-background-size: contain
      data-background-opacity: "1"
    slide-number: true
    embed-resources: true
---

<!-- #TODO -->

<!-- think about where to do the break -->

<!-- think about which slides I could skip if necessary -->

# Workshop

```{r, echo=FALSE}
library(healthiar)
library(tibble)
library(dplyr)
library(purrr)
library(tidyr)
library(stringr)
library(knitr)

options(knitr.kable.max_rows = 100)
set.seed(1)
```

::: fragment
**Part 1 (today)**

Get to know `healthiar`

No need to code!
:::

::: fragment
**In the mean time**

-   Install `healthiar` (& RStudio) - We're here to help!

-   Work on exercises
:::

::: fragment
**Part 2 (on 2 April)**

-   Exercises walk through (in RStudio)

-   Mock case studies - Your turn!

    -   Air pollution & noise

-   Final remarks
:::

# Today

:::::: columns
:::: {.column .fragment .nonincremental .fade-in width="60%"}
**1st hour**

-   \[About healthiar\]

-   \[The healthiar package in RStudio\]

-   Examples

    -   \[Example: attribute_health() using RR\]

    -   \[Example: attribute_health() with RR & uncertainty\]

    -   \[Example: attribute_health() with AR\]

-   [Q&A I] - Please save your questions!

::: fragment
**Break**
:::
::::

::: {.column .fragment .nonincremental .fade-in width="40%"}
**2nd hour**

-   \[healthiar examples II\]

-   \[Post-healthiar workflow\]

-   [Homework - Exercises]

-   [Q&A II] - Please save your questions!

-   [Conclusion]
:::
::::::

# About *`healthiar`*

------------------------------------------------------------------------

::: fragment
Let's jump right in!
:::

::: fragment
Example of a `healthiar` function call

![](images/attribute_health_simple.png){fig-align="center" width="500"}
:::

. . .

What's going on here? Let's rewind a bit

------------------------------------------------------------------------

## Burden of disease - Relative risk

![](images/bod_rr.png)

## Burden of disease - Absolute risk

![](images/bod_ar.png)

## About *`healthiar`* 1/4

![Figure: healthiar overview. DALY = disability-adjusted life years; GBD = global burden of disease; MDI = multidimensional deprivation index; PAF = population attributable fraction; PIF = population impact fraction; YLD = years lived with disability; YLL = years of life lost](images/package_overview.png)

## About *`healthiar`* 2/4

`healthiar` core family members (functions)

-   `attribute_health()` with either relative and absolute risk
-   `attribute_lifetable()` life table analysis (RR & AR)
-   `summary_uncertainty()` Monte Carlo simulation
-   `attribute_mod()` modify an existing assessment
-   `compare()` two scenarios
-   `monetize()` health impacts
-   `cba()` cost-benefit analysis
-   `socialize()` to discover inequalities in health impacts
-   `get_mdi()` creates the BEST-COST MDI (Multidimensional Deprivation Index)
-   `get_daly()` by adding up YLL & YLD

## About *`healthiar`* 3/4

**BEST-COST GitHub repository**

Let's check out the [BEST-COST GitHub repo](https://github.com/best-cost/best-cost_WPs) and the [README file](https://github.com/best-cost/best-cost_WPs/tree/master?tab=readme-ov-file#readme)

[![Landing page of the BEST-COST GitHub repo. The README file tells you how to get started. The folder r_package contains package-related files (including function code in the R folder). Developments are discussed and documented under Issues.](images/bc_github_repo.png)](https://github.com/best-cost/best-cost_WPs)

## About *`healthiar`* 4/4

**Installation**

The [README file](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#readme) contains the following information

-   [GET STARTED WITH THE *healthiar* R PACKAGE](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#get-started-with-the-healthiar-r-package)

-   [Initial installation of the *healthiar* package from GitHub](Initial%20installation%20of%20the%20healthiar%20package%20from%20GitHub)

-   [TERMS OF USE](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#terms-of-use)

-   [NOTE](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#note)

-   [DISCLAIMER](https://github.com/best-cost/best-cost_WPs?tab=readme-ov-file#disclaimer)

. . .

![*README* file of the `healthiar` R package](images/readme.png)

# The *healthiar* package in RStudio

## *`healthiar`* in RStudio 1/3

![RStudio startup screen](images/rstudio_startup_screen.png)

## *`healthiar`* in RStudio 2/3

![Post installation, you can access the `healthiar` package landing page in RStudio by going to the *Packages* tab and then clicking on the `healthiar` package.](images/rstudio_how_to_access_package_landing_page.png)

## *`healthiar`* in RStudio 3/3

![Landing page of the `healthiar` package in RStudio, where you find the package vignettes and function documentation.](images/healthiar_package_landing_page.png)

## Vignette 1/2

::: fragment

vignette

:   long-form guide to a package
:::

::: fragment
![The intro vignette introduces `healthiar` step-by-step and contains (reproducible) examples. You can open the `intro_to_healthiar` vignette within RStudio or as a *HTML* within your browser.](images/rstudio_intro_vignette.png)
:::

## Vignette 2/2

:::: fragment
::: callout-note
The **vignette is a work in progress**: we appreciate any feedback or suggestions you might have to make it more useful to future users!
:::
::::

::: {.fragment .nonincremental}
You can access the intro vignette by

1.  going to the *Packages* tab in RStudio, scrolling to the *healthiar* package and clicking on *healthiar* \> *User guides, package vignettes and other documentation* \> *HTML*

2.  running `*browseVignettes("healthiar")*` and clicking on *HTML* on the page that pops up
:::

## Function documentation 1/3

Let's clarify some R jargon using the function call from before

![](images/attribute_health_simple_annotated.png)

## Function documentation 2/3

:::: fragment
::: callout-tip
Click on a function name in the package landing page to access it or run `?attribute_health`
:::
::::

::: fragment
Any function documentation contains the following sections:

-   *Title* Essence of the function

-   *Description* What does the function do exactly?

-   *Usage* Bare-minimum examples of how to use the function, including default argument value(s)

-   *Arguments* Short description of each function argument, e.g. input type (`numeric` vs. `string`), options (if available), how each argument affects the output, ...

-   *Details* (optional) Additional details about the function

-   *Value* Information about the function output

-   *Examples* (optional) Shows how the function works
:::

## Function documentation 3/3

:::::: columns
::: {.column .fragment .fade-in width="65%"}
![](images/fun_doc_start.png)
:::

:::: {.column .fragment .fade-in width="35"}
::: callout-important
Any arguments without a "*="* symbol after the name have no default and must be user-specified
:::

For a more detailed function documentation walk through see the [Appendix]
::::
::::::

# Example: `attribute_health()` with RR

------------------------------------------------------------------------

## `attribute_health()` with RR

Goal: attribute COPD cases to air pollution

:::: panel-tabset
## Hard-coded input data

```{r, eval=TRUE,include=TRUE,echo=TRUE}
#| code-line-numbers: "|1|2|3|4-7|8|10"

results_pm_copd <-
  attribute_health(
    erf_shape = "log_linear", # Alternatives: "linear", "log_log"
    rr_central = 1.369, 
    rr_increment = 10,  # μg / m^3
    exp_central = 8.85, # μg / m^3
    cutoff_central = 5, # μg / m^3
    bhd_central = 30747 # baseline health data: COPD incidence
  ) 
```

## Pre-loaded data

::: callout-tip
`healthiar` comes with some example data that start with `exdat_` that allow you to test functions.
:::

```{r, eval=TRUE,include=TRUE,echo=TRUE}

results_pm_copd <- attribute_health(
    erf_shape = "log_linear",
    rr_central = exdat_pm_copd$relative_risk, 
    rr_lower = exdat_pm_copd$relative_risk_lower,
    rr_upper = exdat_pm_copd$relative_risk_upper,
    rr_increment = 10, 
    exp_central = exdat_pm_copd$mean_concentration,
    cutoff_central = exdat_pm_copd$cut_off_value,
    bhd_central = exdat_pm_copd$incidents_per_100_000_per_year/1E5*exdat_pm_copd$population_at_risk,
    # bhd_central = exdat_pm_copd$incidence # Uncomment once change committed to main
  ) 
```
::::

## Output structure

::: fragment
Every `attribute` output initially consists of two main lists ("folders"), and additional sub-lists ("sub-folders")

-   `health_main` contains the main results

-   `health_detailed` contains more detailed results and additional information

    -   `impact_raw` contains detailed results

    -   `input_table` contains the input data as entered in the function call

    -   `args` a list of the function arguments as used by R in the background
:::

:::: fragment
::: callout-info
The output tables are in the [`tibble`](https://r4ds.had.co.nz/tibbles.html) format, which is a modern version of the original data frame, and can be used just like a data frame.
:::
::::

## Access the results

:::: fragment
::: callout-tip
You might have a personal preference! However, you might encounter all options.
:::
::::

:::: fragment
::: panel-tabset
## By clicking

Go to the *Environment* tab in RStudio and click on a variable to "open" it. Alternatively, you can use `View(results_pm_copd)`, which has the same effect.

## With `$` operator

`results_pm_copd$health_main$impact_rounded`

Note: after typing the `$` sign you can see all available options by pressing the tab key and use the arrows & tab keys to select an option (or alternatively use the mouse)

## With `[[]]` operator

`results_pm_copd[["health_main"]]`

Note: if the cursor is located within the square braces you can see all available options by pressing the tab key

## With `pluck()` & `pull()`

Using the `purrr::pluck` function to select a list and then the `dplyr::pull` function extract values from a specified column

`results_pm_copd |> purrr::pluck("health_main") |> dplyr::pull("impact_rounded")`

Note: available options can't be displayed automatically using these functions -\> better suited for a more permanent analysis script
:::
::::

## Let's inspect the main results

```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_pm_copd[["health_main"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_pm_copd[["health_detailed"]][["impact_raw"]] |> 
  select(impact_rounded, impact, pop_fraction, erf_ci, rr, exp, bhd) |> 
  knitr::kable()
```

. . .

::: callout-tip
Each row shows a result obtained with all the input data & calculation pathway specifications shown in that row
:::

Some of the most relevant columns include:

-   *impact_rounded* Rounded attributable health impact/burden
-   *impact* Raw impact/burden
-   *pop_fraction* Population attributable fraction (PAF)
-   *erf_ci* Specifies whether `rr_central`, `..._lower` or `..._upper` was used to obtain impact
-   *rr* Raw RR used in calculation
-   *exp* Exposure
-   *bhd* Baseline health data

# Example: `attribute_health()` with RR & uncertainty

------------------------------------------------------------------------

## `attribute_health()` with RR & uncertainty

Goal: attribute lung cancer deaths to PM2.5 exposure

```{r, eval=TRUE,include=TRUE,echo=TRUE}
#| code-line-numbers: "|4-5|8-9|12-13"

results_pm_copd <- attribute_health(
    erf_shape = "log_linear",
    rr_central = 1.369, 
    rr_lower = 1.124, 
    rr_upper = 1.664,
    rr_increment = 10, 
    exp_central = 8.85, 
    exp_lower = 8, 
    exp_upper = 10,
    cutoff_central = 5,
    bhd_central = 30747, 
    bhd_lower = 28000, 
    bhd_upper = 32000
) 
```

## Let's inspect the detailed results

<!-- #TODO -->

:::: {.fragment .fade-in}
::: callout-tip
See the intro vignette for a detailed description of output columns.
:::
::::

::: {.fragment .fade-in}
The `health_detailed` output table contains all different combinations of the arguments with uncertainty. E.g. `rr_central` with `exp_lower` and `bhd_upper`, ...
:::

::: {.fragment .fade-in}
```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_pm_copd[["health_detailed"]][["impact_raw"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_pm_copd[["health_detailed"]][["impact_raw"]] |> knitr::kable()
```
:::

# Example: `attribute_health()` with AR

## `attribute_health()` with AR

Goal: attribute cases of high annoyance (HA) to noise exposure

::: fragment
![Source input data: NIPH](images/example_noise_ha.png)
:::

::: fragment
```{r}
results_noise_ha <- attribute_health(
    approach_risk = "absolute_risk",
    exp_central = c(57.5, 62.5, 67.5, 72.5, 77.5),
    pop_exp = c(387500, 286000, 191800, 72200, 7700),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2"
)
```
:::

## Results per noise exposure band

. . .

```{r, echo=TRUE, eval=FALSE, include=FALSE}
results_noise_ha[["health_detailed"]][["impact_raw"]] |> knitr::kable()
```

```{r, echo=FALSE, eval=TRUE, include=TRUE}
results_noise_ha[["health_detailed"]][["impact_raw"]] |> 
  select(exposure_dimension, exp, pop_exp, impact) |> 
  knitr::kable()
```

# Example: Iteration with `attribute_health()`

## Iteration function call

::: fragment
Goal: attribute disease cases to PM2.5 exposure in multiple geographic units, such as municipalities, provinces, countries, ...
:::

:::: fragment
Here the we want to aggregate results by language region (`"Ger", "Fra", "Ita"`)

::: panel-tabset
## list()

```{r}
#| code-line-numbers: "|2-3|8-9|"
#| output-location: fragment
results_iteration <- attribute_health(
    geo_id_disaggregated = c("Zurich", "Basel", "Geneva", "Ticino", "Valais"), 
    geo_id_aggregated = c("Ger","Ger","Fra","Ita","Fra"),
    rr_central = 1.369,
    rr_increment = 10, 
    cutoff_central = 5,
    erf_shape = "log_linear",
    exp_central = list(11, 11, 10, 8, 7),
    bhd_central = list(4000, 2500, 3000, 1500, 500)
)
```

## as.list()

```{r}
results_iteration <- attribute_health(
    geo_id_disaggregated = c("Zurich", "Basel", "Geneva", "Ticino", "Valais"), 
    geo_id_aggregated = c("Ger","Ger","Fra","Ita","Fra"),
    rr_central = 1.369,
    rr_increment = 10, 
    cutoff_central = 5,
    erf_shape = "log_linear",
    exp_central = as.list(c(11, 11, 10, 8, 7)),
    bhd_central = as.list(c(4000, 2500, 3000, 1500, 500))
)
```
:::
::::

::::: fragment
:::: callout-tip
::: nonincremental
-   For iterations, enter geo unit-specific inputs as lists use `as.list()` function

-   Feed unique geo ID's as a vector to the `geo_id_disaggregated` argument (e.g. municipality names)

-   Optional: aggregate geo unit-specific results by providing higher-level ID's (e.g. region names) as a vector to the `geo_id_aggregated` argument
:::
::::
:::::

## Let's check the main iteration results!

:::: fragment
::: callout-tip
The main output contains aggregated results if available, or disaggregated results if no aggregation ID was provided
:::

```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_iteration[["health_main"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_iteration[["health_main"]] |> 
  dplyr::select(geo_id_aggregated, impact_rounded, erf_ci, exp_ci, bhd_ci) |> 
  knitr::kable()
```
::::

## Let's check the detailed iteration results!

::: fragment
```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_iteration[["health_detailed"]][["impact_raw"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_iteration[["health_detailed"]][["impact_raw"]] |> 
  select(geo_id_disaggregated, geo_id_aggregated, impact_rounded) |> 
  knitr::kable()
```
:::

# Q&A I

# Break

# Example: compare()

::: fragment
Goal: comparison of two scenarios

-   

    1.  Use `attribute_health()` to calculate burden of scenarios A & B

-   

    2.  Use `compare()` to compare scenarios A & B
:::

::::: columns
::: {.column .fragment width="50%"}
```{r}
scenario_A <- attribute_health(
    exp_central = 8.85,   # EXPOSURE 1
    cutoff_central = 5, 
    bhd_central = 25000,
    approach_risk = "relative_risk",
    erf_shape = "log_linear",
    rr_central = 1.118,
    rr_increment = 10)
```
:::

::: {.column .fragment width="50%"}
```{r}
scenario_B <- attribute_health(
    exp_central = 6,     # EXPOSURE 2
    cutoff_central = 5, 
    bhd_central = 25000,
    approach_risk = "relative_risk",
    erf_shape = "log_linear",
    rr_central = 1.118,
    rr_increment = 10)
```
:::
:::::

::: fragment
```{r}

results_comparison <- compare(
  
  approach_comparison = "delta", # or "pif" (population impact fraction)
  
  output_attribute_1 = scenario_A,
  
  output_attribute_2 = scenario_B
)
```
:::

## Let's check the comparison results!

```{r, echo=TRUE,eval=FALSE,include=FALSE}
results_comparison[["health_main"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_comparison[["health_main"]] |> 
  dplyr::select(
    impact, impact_rounded,
    impact_1, impact_2,
    bhd,
    dplyr::starts_with("exp_"),
    -dplyr::starts_with("exp_ci"), # remove col "exp_ci"
    dplyr::starts_with("rr_con")) |> 
  dplyr::slice_head() |> 
  knitr::kable()
```

# Example: `monetize()`

## Example: `monetize()`

::: fragment
Different monetization pathways / options are available

-   **Direct monetization** (default) after obtaining the health impacts
-   **Indirect monetization** before the health impacts
-   **Discounting** yes/no
-   **Inflation** yes/no
-   **Stand-alone use** the function can either monetize a healthiar output or an "external" health impact
:::

::: fragment
```{r}
results_monetization <- 
  monetize(
    output_healthiar = results_pm_copd,
    approach_discount = "direct",
    discount_shape = "exponential",
    discount_rate = 0.03,
    discount_years = 5,
    valuation = 20)
```
:::

## Let's check the `monetize()` output

:::: .callout-info
::: {.fragment .nonincremental}
`monetize()` adds two main lists ("folders") to the inputted health impacts

-   `monetization_main` contains total results

-   `monetization_detailed`

    -   `by_year` yearly results

:::
::::

::: {.fragment}
```{r, echo=TRUE,eval=FALSE,include=FALSE}
results_monetization[["monetization_main"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_monetization[["monetization_main"]] |> 
  dplyr::select(
    impact, monetized_impact, discount_rate, valuation, 
    monetized_impact_before_inflation_and_discount, 
    monetized_impact_after_inflation_and_discount) |> 
  dplyr::slice_head() |> 
  knitr::kable()
```
:::


# Example: `socialize()`

## Example: `socialize()`

`socialize()` features

-   **Stand-alone use** the function can either be used with an `attribute_...` output or an *external* health impact
-   **Deprivation indicator** BEST-COST Multidimensional Deprivation Index (MDI) or any other (single-)indicator, e.g. house hold income

::: fragment
First create an example to be *socialized* using example data set `exdat_mdi`

```{r}
results_social <- attribute_health(
    geo_id_disaggregated = exdat_mdi$CS01012020,
    rr_central = 1.08,
    erf_shape = "log_linear", 
    rr_increment = 10,
    exp_central = as.list(exdat_mdi$PM25_MEAN),
    cutoff_central = 0,
    bhd_central = as.list(exdat_mdi$MORTALITY_TOTAL),
    population = exdat_mdi$POPULATION
)
```
:::

::: fragment
```{r}
results_social <- socialize(
  output_healthiar = results_social,
  geo_id_disaggregated = exdat_mdi$CS01012020,
  social_indicator = exdat_mdi$score,
  n_quantile = 10
)
```
:::

## Let's check the `socialize()` results

:::: .callout-info
::: {.fragment .nonincremental}
`socialize()` adds two main lists ("folders") to the inputted health impacts

-   `social_main` contains total results

-   `social_detailed`

    -   `results_detailed`
    
    -   `overview_quantiles`

:::
::::

```{r, echo=TRUE,eval=FALSE,include=FALSE}
results_social[["social_main"]]
```

```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_social[["social_main"]] |> 
  slice(3,4) |> 
  knitr::kable()
```

# Additional features

Additional existing `healthiar` functions

-   `attribute_health()` with the argument `approach_multiexposure` for analysis with correlated exposures
-   `attribute_lifetable()` for YLL
-   `get_daly` as the sum of YLL and YLD
-   `attribute_mod()` modify an existing `healthiar` assessment
-   `cba()` cost-benefit analysis
-   `get_mdi()` creates the BEST-COST Multidimensional Deprivation Index (MDI)
-   `summarize_uncertainty()` with Monte Carlo simulation

::: callout-note
Coming (relatively) soon: function examples in the intro vignette!
:::

# Post-`healthiar` workflow

## Export results

::: panel-tabset
## Export as `.csv` file

```{r}
write.csv(x = results_pm_copd$health_main, file = "exported_results/results_pm_copd.csv")
```

## Save as `.Rdata` file

```{r}
save(results_pm_copd, file = "exported_results/results_pm_copd.Rdata")
```

## Export to Excel (as `.xlsx` file)

```{r}
openxlsx::write.xlsx(x = results_pm_copd$health_main, file = "exported_results/results_pm_copd.xlsx")
```

![*Exported to .xlsx format*](images/export_xlsx.png)
:::

## Visualize results

Visualization is out of scope of `healthiar`. You can visualize in

-   R, e.g. with the `ggplot2` package ([online book by the creator](https://ggplot2-book.org/))
-   Excel (export results first)
-   Other tools

# Homework - Exercises

## Exercise 1 - RR

-   How many lung cancer cases are attributable to PM2.5 exposure in a single year?

    -   With a **cutoff of 5** microgram/m\^3 ?

    -   With **no cutoff**?

-   What's the direct treatment **costs** per year in the no cutoff scenario?

**Data**

-   Population-weighted annual mean exposure: **10** microgram/m\^3
-   Baseline health data: **100'000** cases per year
-   Relative risk: **1.06** per 10 microgram/m\^3 exposure increment
-   ERF shape: linear
-   Average treatment cost: **50'000** EURO

## Exercise 2 - AR

How many people are highly annoyed due to noise exposure

-   In **total** ?
-   In the **highest exposure band** ?

*Advanced* How large is the health burden measured in YLD? - Assume that the population is exposed for **1 year** - Tip: check the function documentation of `attribute_health` to see which extra argument must be used to express the burden in YLD

**Data**

-   Use the data in the `healthiar` example data set `exdat_noise_ha`
-   Use the exposure values from the column `exposure_mean`
-   Use the ERF `90-3.1162*c+0.0342*c^2`
-   *Advanced* disability weight = `0.02`

::: callout-tip
Once `healthiar` is installed and loaded you can use the example data directly or add it to your *Environment* in RStudio by assigning it to a variable, e.g. `data <- exdat_noise_ha`
:::

# Q&A II

# Conclusion

note: stress that they must install & test healthiar before 2nd WS

If you encounter challenges during installation, get in touch with us!

------------------------------------------------------------------------

Thank you for your attention, and happy coding!

# Appendix

## Function documentation

::::::: panel-tabset
### Title

![*Title section*](images/fun_doc_title.png)

The title summarizes the function of the function (hehe) in one sentence.

The title shows up next to the function name in the package landing page.

### Description

![*Description section* provides additional details about the function's purpose](images/fun_doc_desc.png)

### Usage

![*Usage section* In the usage section you can find a bare-minimum function "template", which can either be auto-generated or created manually, as in this case.](images/fun_doc_usage.png)

::: callout-important
Any arguments that appear without a *=* symbol after them in the usage section have to be user-specified in all function call.
:::

::: callout-note
The inputs to the arguments in the usage section are default inputs
:::

### Arguments

![*Arguments section* This is the core section of the function documentation, where input type (`numeric` vs. `string`) & input options (if available) are specified.](images/fun_doc_arguments.png)

### Details

![Details section (optional) Additional details about the function](images/fun_doc_details.png)

::: callout-warning
Depending on the function, this section might be not very developed at the moment. Sometimes more function details are found in the intro vignette.
:::

### Value

![*Value section* Information about the function output](images/fun_doc_value.png)

### Examples

![Example section (optional) Shows how the function works](images/fun_doc_examples.png)

::: callout-tip
By clicking on `Run examples` the example(s) are executed and the output shown
:::

### Examples output

![*Example output* Obtained by clicking on `Run examples` (see previous slide)](images/fun_doc_examples_output.png)
:::::::

------------------------------------------------------------------------

**Solution Exercise 1**

How many COPD cases are attributable to PM2.5 exposure in a single year?

::: panel-tabset
## cutoff = 5

```{r}
results_with_cutoff <- attribute_health(
    erf_shape = "linear",
    rr_central = 1.06, 
    rr_increment = 10,  # μg / m^3
    exp_central = 10, # μg / m^3
    cutoff_central = 5, # μg / m^3
    bhd_central = 100000 # baseline health data: COPD incidence
)

# Attributable impact
print(results_with_cutoff$health_main$impact_rounded)
```

## cutoff = 0

```{r}
results_no_cutoff <- attribute_health(
    erf_shape = "linear",
    rr_central = 1.06, 
    rr_increment = 10,
    exp_central = 10,
    cutoff_central = 0,
    bhd_central = 100000
)

# Attributable impact
print(results_no_cutoff$health_main$impact_rounded)
```

## Costs

```{r}
results_monetized <- monetize(
  output_healthiar = results_no_cutoff,
  valuation = 50000
)

# Cost
print(results_monetized$monetization_main$monetized_impact_rounded)
```
:::

------------------------------------------------------------------------

**Solution Exercise 2**

::: panel-tabset
## Total

```{r}

results_noise_ha <- attribute_health(
    approach_risk = "absolute_risk",
    exp_central = exdat_noise_ha$exposure_mean,
    pop_exp = exdat_noise_ha$population_exposed_total,
    erf_eq_central = "90-3.1162*c+0.0342*c^2"
)

# Total attributable cases of high annoyance
print(results_noise_ha$health_main$impact_rounded)
```

## Highest exposure

```{r}
results_noise_ha <- attribute_health(
    approach_risk = "absolute_risk",
    exp_central = exdat_noise_ha$exposure_mean,
    pop_exp = exdat_noise_ha$population_exposed_total,
    erf_eq_central = "90-3.1162*c+0.0342*c^2"
)

# Attributable cases of high annoyance from exposure in highest noise band
print(results_noise_ha$health_detailed$impact_raw$impact[5])
```

## Advanced: YLD

```{r}
results_noise_ha_yld <- attribute_health(
    approach_risk = "absolute_risk",
    exp_central = exdat_noise_ha$exposure_mean,
    pop_exp = exdat_noise_ha$population_exposed_total,
    erf_eq_central = "90-3.1162*c+0.0342*c^2",
    dw_central = 0.02,
    duration_central = 1
)

# Attributable number of YLD due to high annoyance
print(results_noise_ha_yld$health_main$impact_rounded)
```
:::
