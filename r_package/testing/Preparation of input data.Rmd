---
title: "Preparation of input data"
author: "Axel Luyten"
date: "`r Sys.Date()`"
output: pdf_document
---

This script prepares the input data for the use in the {bestcost} functions. The R Environment (including all variables created during the script) is exported in the end in a ".Rdata" file.

# Introduction
The R script required the loading of certain R packages. 
```{r Load packages, include=FALSE}

# Clear R environment
rm(list = ls())

# Load required packages

# to read data
library(readr)
library(readxl)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)

library(zoo)


## to export tables in excel format
library(openxlsx)

```


```{r Useful variables}
#Decide 
# the target increment (increase of concentration) of the pm RRs 
# and PM fraction
increment_target_pm <- 10 # ug/m3

# Define existing PM fractions
pm_fractions <- c("PM2.5", "PM10")

# Set targeted PM fraction
pm_target <- "PM2.5"

# PM fraction that is not targeted
pm_no_target <- pm_fractions[!pm_fractions %in% pm_target]

# Pollutants to be considered in the hra based on available exposure data
pollutants_hra <- c(pm_target, "NO2")

# Define sex
sex <-  c("male", "female")

# Define values in the confidence interval (ci)
ci <- c("central", "lower", "upper")

# Define Outcome groups
groups <-
  data.frame(
    agegroup = c("below1", "from30"),
    outcome_group = c("infants", "adults")
  )

outcomeGroups <- groups$outcome_group

#IMPORTANT: Year to be run in the analysis air pollution HRA (health risk assessment)
# This should be one (or more than one) from the years_withData
# Change it as needed
year_hra <- "2019"
```
 
 
```{r Functions}

# Create function to join central estimate of RR with the lower and upper bound
paste_CI <- 
  function(central, lower, upper){
     paste0(central," [", lower, "; ", upper, "]")
  }

# Create function to round keeping zeros in decimals (e.g. 2.0 instead of 2)
# We use sprintf() instead of round() because 
# the former keep the zeros unlike the latter
round_keeping0 <- 
  function(value, decimals){
    sprintf(paste0("%.", decimals, "f"), value)
  }
  
# Create function to round the values of the RR and then paste
paste_round_CI <- 
  function(central, lower, upper, decimals){
    paste0(round_keeping0(central, decimals)," [",  
           round_keeping0(lower, decimals), "; ", 
           round_keeping0(upper, decimals), "]")
  }

# r Functions to rescale RR 

# Define function to re-scale the RR regarding the considered increment
rescale_rr_increment <- 
  function(rr, increment_original, increment_target){

    rescaled_increment <- 
      exp(log(rr) * increment_target / increment_original)
 
  }

# Conversion factor for PM fraction
get_conversionFactor_pmFraction <-
  function(pm_original, pm_target){
    
    # Divide the percentage (%) by 100 to get the ratio (0.) 
    # And depending on the pm selected choose the default or the inverse form
    conversionFactor <- 
      ifelse(pm_original %in% "PM2.5" & pm_target %in% "PM10",
             1/(percentage_pm2.5_in_pm10/100),
             ifelse(pm_original %in% "PM10" & pm_target %in% "PM2.5",
                    percentage_pm2.5_in_pm10/100,
                    1))
  }

# Define function to re-scale the RR regarding the considered PM fraction
rescale_conc_pmFraction <- 
  function(conc, pm_original, pm_target){
  # Get conversion factor for the PM fraction
    conversionFactor <- 
      get_conversionFactor_pmFraction(pm_original, pm_target)
    # Apply the conversion factor to get the concentration in the right fraction
    rescaled_fraction <- 
      conc * conversionFactor
  }

# Create function to get lifetable with population
get_lifetable_withPopulation <-
  function(lifetable, population, year_of_analysis, nonNatural_mortality){
        
    # Life table for 
    lifetable_withPopulation <- 
      # Join lifetable and population by age 
      dplyr::left_join(population,
                       lifetable,
                        by = "age")%>%
      dplyr::left_join(.,
                       nonNatural_mortality,
                       by = "age")%>%
      # Rename the column to show that it is total (and not only natural) mortality
      dplyr::rename("death_probability_total" = "death_probability")%>%
      # We close the last row assigning a 1 for probability to die and 
      # a 0 to probability to survive
      dplyr::mutate(death_probability_total = replace(death_probability_total, n(), 1),
                    death_probability_natural = death_probability_total * (1-percent_nonNatural))%>%
      # Add year to population column
      dplyr::rename("population_{year_of_analysis}" := population)
  }





digest_airqplus_export_singlebhd <- 
  function(airqplus_export){
    
    airqplus_export <- 
      airqplus_export %>%
      # Rename variables
      setNames(c("variable", "value"))%>%
      dplyr::rowwise()%>%
      # Add and edit columns
      dplyr::mutate(
        # To identify the sections in the table (all capital letters)
        section_break = !stringr::str_detect(variable, "[[:lower:]]") & stringr::str_detect(variable, "[[:alpha:]]"),
        # To give section name to the first row (replacing empty spaces with _ and making lower case)
        section_name = ifelse(section_break, gsub(" ", "_", tolower(variable)), NA))%>%
      # Stop rowwise
      dplyr::ungroup()%>%
      # Remove line breaks
      dplyr::mutate(
        section_name = gsub("\r", "", section_name))%>%
      # Fill the NAs in section_name with the first non-NA above
      tidyr::fill(section_name) %>%
      # Remove the rows with the section name (not needed anymore since they are in a column now)
      dplyr::filter(!section_break)%>%
      # Remove column section_break (not needed anymore because section_name is defined)
      dplyr::select(-section_break) 
    
    # The results need to editing
    airqplus_output <- 
       airqplus_export %>%
      # Keep only rows from output
      dplyr::filter(
        section_name %in% c("evaluation_results")) %>%
      # Remove rows with NA
      na.omit() %>%
      # Remove last ; (no value behind)
      dplyr::mutate(value = gsub("\\;$", "", value))%>%
      # Split columns that are separated by ;
      tidyr::separate( 
          col = value,
          sep = ";",
          into = c("value_central", "value_lower", "value_upper"))%>%
      # Remove the first row without numeric value
      dplyr::slice(-1) %>%
      # Make the table longer to fit into the same structrue as the input table
      tidyr::pivot_longer(cols = starts_with("value_"), 
                          names_to = "suffix",
                          names_prefix = "value_",
                          values_to = "value") %>%
      # Paste columns variable and suffix to get the specific resulty by CI
      tidyr::unite("variable", variable, suffix)


      airqplus_ready <- 
        airqplus_export %>%
        # Keep only rows from input
        dplyr::filter(
          section_name %in% 
            c("analysis_properties", "pollution_concentration", "evaluation_parameters")) %>%
        # Add rows of results
        dplyr::bind_rows(airqplus_output)%>%
        # Edit string of variable to make it standard
        dplyr::mutate(
          # Remove : or parenthesis
          variable = gsub(":|\\(|\\)", "", variable),
          # Remove line breaks
          variable = gsub("\r", "", variable),
          # no capital letters
          variable = tolower(variable),
          # Replace space with _
          variable = gsub(" ", "_", variable ),
          #Replace - with _
          variable = gsub("-", "_", variable),
          # Remove comma from value
          value = gsub(",", "", value))%>%
        # Pivot wider to have specific format for each value
        dplyr::select(variable, value)%>%
        tidyr::pivot_wider(names_from = variable, 
                           values_from = value)%>%
        # Convert percent in proportion
        dplyr::mutate(across(starts_with("estimated_attributable_proportion"),
                             readr::parse_number))%>%
        # Divide by 100 because the columns were a percentage originally (e.g. 5% = 0.05)
         dplyr::mutate(across(starts_with("estimated_attributable_proportion"),
                              ~./100)) %>%
        # Convert to numeric
        dplyr::mutate(across(-c(analysis_name, type, pollutant, location,
                                analyis_comment, evaluation_type, evaluation_name, 
                                health_endpoint, calculation_method), 
                             as.numeric))
      
  }

  


digest_airqplus_export_lifetable <- 
  function(airqplus_export){
    
    airqplus_export_edited <- 
      airqplus_export %>%
      # Rename variables
      setNames(c("variable", "value")) %>%
      # Remove ";" at the end of the string 
      # Important to be done before
      dplyr::mutate(
        value = gsub("\\;$" ,"", value)) %>%
      # Add columns for dimension and dimension_below
      dplyr::mutate(
        # Identify dimension
        dimension = stringr::str_count(value, "\\;")+1,
        # Take the dimension from the row below (this is to be identify sub-sections)
        dimension_below = dplyr::lead(dimension, n=1)) %>%
      # Identify breaks 
      dplyr::rowwise() %>%
      dplyr::mutate(
        # To identify the sections in the table (all capital letters)
        section_break = !stringr::str_detect(variable, "[[:lower:]]") &
          stringr::str_detect(variable, "[[:alpha:]]"),
        subsection_break = is.na(value) & dimension_below > 1) %>%
      # Stop rowwise
      dplyr::ungroup()%>%
      
      # Edit columns to standardize the strings
      dplyr::mutate(
        # Remove : or parenthesis
        variable = gsub(":|\\(|\\)", "", variable),
        # Remove line breaks
        variable = gsub("\\\r", "", variable),
        # no capital letters
        variable = tolower(variable),
        # Replace space with _
        variable = gsub(" ", "_", variable ),
        # Replace - with _
        variable = gsub("-", "_", variable),
        # Remove comma from value
        value = gsub(",", "", value))%>%
      # Give names to sections and subsections
      dplyr::mutate(
        # To identify the sections in the table (all capital letters)
        section_name = ifelse(section_break, 
                              variable, 
                              NA),
        subsection_name = ifelse(subsection_break, 
                                 variable,
                                 NA)) %>%
      # Fill the NAs in (sub)section_name with the first non-NA above
      tidyr::fill(c("section_name", "subsection_name")) %>%
      # If subsection is NA assign section name
      dplyr::mutate(subsection_name = ifelse(is.na(subsection_name), 
                                             section_name, 
                                             subsection_name))%>%
      # Remove the rows with the (sub)section name (not needed anymore since they are in a column now)
      dplyr::filter(!section_break) %>%
      dplyr::filter(!subsection_break) %>%
      # Remove column (sub)section_break (not needed anymore because section_name is defined)
      dplyr::select(-section_break, -subsection_break, 
                    -dimension_below)
    
    # Create nested list by section and subsecton name
    airqplus_list <-
      split(airqplus_export_edited, airqplus_export_edited$section_name) %>%
      purrr::map(., function(x) split(x, x$subsection_name)) %>%
      purrr::map(., ~ purrr::map(., function(x) 
        tidyr::separate_wider_delim(
          x,
          cols = value,
          delim = ";",
          names = paste0("value_", 1:max(x$dimension, na.rm = TRUE)))))
     
    
    
    # Define the data frames that will be used as outcome of this function
    # INPUT (EXCEPT POP)
    airqplus_input <-
      airqplus_export_edited %>%
          dplyr::filter(subsection_name %in% c("evaluation_parameters", "pollution_concentration")) %>%
      # Remove columns that are not needed anymore
      dplyr::select(-dimension, -section_name, -subsection_name)%>%
      # Pivot wider to have a 1-row data frame (easier to extract information)
      tidyr::pivot_wider(values_from = "value",             
                         names_from = "variable") %>%
      # Convert to numeric
        dplyr::mutate(across(-c(evaluation_type, evaluation_name, 
                                health_endpoint, calculation_method), 
                             as.numeric))
      
      
    # POP
    # population data including probability of dying  
    airqplus_pop <- 
      airqplus_list[["evaluation_parameters"]][["population_data"]] 
    
    # Rename columns
    names(airqplus_pop) <-
      # If starting with "value_" then adopt the name of the first row
      ifelse(grepl("value_|variable", names(airqplus_pop)),
             paste0(airqplus_pop[1,]),
             names(airqplus_pop)) %>%
      # Standardize names
      # Replace " -(" with "_"
      gsub(" ", "_",.) %>%
      # Remove bracket and empty spaces
      gsub("\\(|\\)|\\-", "",.) %>%
      # Lower case
      tolower(.)
    
    # Continue editing
    airqplus_pop <- 
      airqplus_pop %>%
      # Remove column dimension (not needed anymore)
      dplyr::select(-dimension) %>%
      # Remove the first row without numeric value
      dplyr::slice(-1)%>%
      # Convert to numeric
      dplyr::mutate(across(-c(section_name, -subsection_name),
                           as.numeric))
    
    # OUTPUT
    # The results need to editing
    airqplus_yll <- 
      airqplus_list[["evaluation_results"]][["years_of_life_lost"]] 
    
    # Rename columns
    names(airqplus_yll) <-
      # If starting with "value_" then adopt the name of the first row
      ifelse(grepl("value_", names(airqplus_yll)),
             paste0("value_", airqplus_yll[1,]),
             names(airqplus_yll)) %>%
      # Standardize names
      # Replace " -(" with "_"
      gsub(" - \\(", "_",.) %>%
      # Remove bracket and empty spaces
      gsub("\\)| ", "",.) %>%
      # Lower case
      tolower(.) 
    
    # Continue editing
    airqplus_yll <- 
      airqplus_yll %>%
      # Remove column dimension (not needed anymore)
      dplyr::select(-dimension) %>%
      # Remove the first row without numeric value
      dplyr::slice(-1) %>%
      # Pivot wider
      tidyr::pivot_wider(values_from = starts_with("value_"),             
                         names_from = "variable")%>%
      # Convert to numeric
      dplyr::mutate(across(-c(section_name, -subsection_name), 
                           as.numeric))
      
    
    
    # Build the list
    airqplus_ready <-
      list(
        input = airqplus_input,
        pop = airqplus_pop,
        output = airqplus_yll
      )

  }


# Check if the results of the bestcost package are the same as in an alternative source (tool, assessment, etc.)
check_bestcost <-
  function(result_list_bestcost, result_vector_alternative){
    # Store the central estimate of the bestcost assessment
    
  result_vector_bestcost <- 
    result_list_bestcost[["main"]]%>%
    # Set order of rows
    dplyr::arrange(factor(erf_ci, levels = c("central", "lower", "upper")))%>%
    dplyr::select(impact_rounded) %>%
    unlist()
  
  # Obtain difference between the result of using bestcost and other source
  difference_prop <- 
    round(
      (result_vector_bestcost - result_vector_alternative)/result_vector_alternative,
      4)
  difference_percent <- paste0(difference_prop*100, "%")
  
  # Check difference between bestcost and alternative source
  # First the show the difference between bestcost results and alternative source
  cat(
    paste0("Difference (central, lower, upper): ", paste(difference_percent, collapse = "; "),"\n"))
  # Second show message with colors
  if(all(difference_prop == 0)){
    cat(paste(crayon::cyan("Right. Bestcost and alternative with identical results.")))
    
    }else if(all(difference_prop > 0 & difference_prop < 0.01)){
      cat(paste0("best-cost: ", paste(result_vector_bestcost, collapse = ";")),"\n", 
          paste0("alternative_source: ", paste(result_vector_alternative, collapse = "; ")),"\n", 
          crayon::yellow("Slight difference (<1%). Bestcost and alternative with similar but not identical results."))
      
    } else{
    cat(paste0("best-cost: ", paste(result_vector_bestcost, collapse = ";")),"\n", 
        paste0("alternative_source: ", paste(result_vector_alternative, collapse = "; ")),"\n", 
        crayon::red("Attention! Check! Bestcost and alternative with different results."))}
  
  }



runif_with_seed <- 
  function(n, min, max, seed){
    set.seed(seed)
    
    output <- runif(n, min, max)
  }


```


# Read raw input
```{r Read data}

# Generic data
percentage_pm2.5_in_pm10 <- 
  read.csv("../testing/input/data/generic_data.csv", sep = ";") %>% 
  dplyr::filter(parameter_name %in% "percentage_pm2.5_in_pm10") %>%
  dplyr::select(value) %>%
  dplyr::pull()

# RR data (inserted manually in the csv table)
rr_rawdata <- 
  read.csv("../testing/input/data/rr.csv",
           sep = ";",
           na.strings=c("NA", ""))

# Population data by age (To be used in the life table approach)
population_byAge_rawdata <-
  read.csv2("../testing/input/data/population/population_byAge_bySex_CH_2018_2019.csv") %>%
  # Rename columns
  dplyr::rename("age" = "Alter",
                "male_end2018" = "Mann.2018",
                "female_end2018" = "Frau.2018",
                "male_end2019" = "Mann.2019",
                "female_end2019" = "Frau.2019") %>%
  # Remove "Jahre" 
    dplyr::mutate(
      age = gsub(" Jahre| Jahr","", age)) #gsub() for pattern replacement

# Baseline health data 
bhd_rawdata <- 
  read.csv("../testing/input/data/bhd.csv", sep = ";")

# Read raw life table data
lifetable <- list()
for(s in sex){
  # Life table for 2019
  # Average of the period 2016-2020
  lifetable[[s]] <- 
    read.csv2(
      # The raw data are for the period 2013-2020 but we focused on 2015-2019 (five years period)
      paste0("../testing/input/data/life_tables/life_table_2013_2020_",
             s,
             ".csv"))
}


# Read raw non-natural mortality data for 2019 (average of the period 2009-2019)
nonNatural_mortality_rawdata<- 
   list(
     male = read.csv2("../testing/input/data/mortality/nonNatural_mortality_byAge_2009_2019_male.csv",
                      na.strings =".", 
                      check.names = FALSE),
     female = read.csv2("../testing/input/data/mortality/nonNatural_mortality_byAge_2009_2019_female.csv",
                        na.strings =".", 
                      check.names = FALSE))

# Read total mortality raw data for 2019 (average of the period 2009-2019)
total_mortality_rawdata <- 
  list(
    male = read.csv2("../testing/input/data/mortality/total_mortality_byAge_2009_2019_male.csv",
                     na.strings =".", 
                      check.names = FALSE),
    female = read.csv2("../testing/input/data/mortality/total_mortality_byAge_2009_2019_female.csv",
                       na.strings =".", 
                      check.names = FALSE))

# Concentration data
# Scenario
exp_rawdata <- 
  read.csv("../testing/input/data/exp.csv",
           sep = ";",
           na.strings=c("NA", ""))

# cutoff
cutoff_rawdata <- 
  # Read data
  read.csv("../testing/input/data/cutoff.csv",
           sep = ";",
           na.strings=c("NA", ""))


# cutoff
social_mort_rawdata <- 
  ## import burden
  read.csv("../testing/input/inequalities/mort_pm25_sector_2019.csv")

## import derpivation index
social_bimd_rawdata <- 
  read.csv("../testing/input/inequalities/BIMD_2011_WITHOUT_HEALTH_ELLIS_WIDE.csv")


```


```{r Read and digest input data from AirQ+}


airqplus_copd_export <-
  # Read csv file from AirQ+ export for incidence of COPD
  readr::read_delim("../testing/input/airqplus_cases/airqplus_COPD.csv",
                    delim = ";",
                    col_types = cols())
# Digest the data (make it ready for testing the package)
airqplus_pm_copd <- 
  digest_airqplus_export_singlebhd(airqplus_export = airqplus_copd_export)
 
# Data sets from the AirQ+ manual (for testing of function get_prob_dying())
airqplus_deaths_pop_multipleYear <-
  read.csv2("../testing/input/airqplus_cases/airqplus_manual_multipleYear.csv")
airqplus_deaths_pop_singleYear <-
  read.csv2("../testing/input/airqplus_cases/airqplus_manual_age0to40_singleYear.csv")



# Read csv file from AirQ+ export for deaths and YLLs
airqplus_deaths_yll_export <-
  readr::read_delim(
    "../testing/input/airqplus_cases/airqplus_deaths_yll_lifetable_adults.csv",
    delim = ";",
    col_types = cols())

# Digest the data (make it ready for testing the package)
airqplus_pm_deaths_yll <- 
  digest_airqplus_export_lifetable(airqplus_export = airqplus_deaths_yll_export)



```


```{r Read NIPH asssessment for noise}

# The assessment for noise was provided by NIPH

## High annoyance (HA)
niph_noise_ha_excel <-
  # Read csv file
  readxl::read_xlsx(path = "../testing/input/noise_niph/example_road_noise_niph.xlsx",
                    sheet = "Absolute_risk_HA")

## High sleep disturbance (HSD)
niph_noise_hsd_excel <-
  # Read csv file
  readxl::read_xlsx(path = "../testing/input/noise_niph/example_road_noise_niph.xlsx",
                    sheet = "Absolute_risk_HSD")

## Ischemic Heart Disease (IHD)
niph_noise_ihd_excel <-
  # Read csv file
  readxl::read_xlsx(path = "../testing/input/noise_niph/example_road_noise_niph.xlsx",
                    sheet = "Relative_risk_IHD_WHO_2003a")


```



# Edit single input data

## RR data
```{r Edit RR (rescale inclusive)}
rr_data <- 
  rr_rawdata %>%
  # Select only rrs that are relevant 
  dplyr::filter(!is.na(choice_pair)) %>%
  # Reshape RRs from wide to long (to enable editing RRs by row)
  tidyr::pivot_longer(c(rr_central, rr_lower, rr_upper),
                      names_to = "ci",
                      names_prefix = "rr_", 
                      values_to = "rr") %>%
  # Add a copy of columns with the original values (before re-scaling)
  dplyr::mutate(
    rr_pollutant_original = pollutant,
    rr_original = rr,
    rr_increment_original = rr_increment,
  # Add the target RR increment (default increase of concentration) 
  # for each pollutant
    rr_increment_target =
      ifelse(pollutant %in% c(pm_fractions, "NO2"), 10, NA),
      # ifelse(pollutant %in% "BC", 0.44, NA))) %>%
      # ifelse(pollutant %in% "O3", , NA)))) %>% 
      # If O3 is included, the O3 increment is to be decided
  # Re-scale concentration of PM fractions in RRs
    rr_increment_rescaled = 
      rescale_conc_pmFraction(
        conc = rr_increment_original,
        pm_original = rr_pollutant_original,
        pm_target = pm_target),
  # Re-scale to the target increment
    rr_rescaled = 
      rescale_rr_increment(
        rr = rr,
        increment_original = rr_increment_rescaled,
        increment_target = rr_increment_target),
    rr = rr_rescaled) %>%
  # Modify columns based on target
  dplyr::mutate(
    pollutant = 
      ifelse(pollutant %in% pm_no_target, 
             pm_target, 
             rr_pollutant_original),
    rr_increment = 
      ifelse(!rr_increment %in% rr_increment_target, 
             rr_increment_target, 
             rr_increment)) %>%

  # Change format of source
  # Remove brackets and spaces
  dplyr::mutate(
    rr_source_rFormat = 
      paste(
        # First word
        stringr::word(rr_source, 1),
        # Year between brackets
        stringr::str_extract(rr_source, "(?<=\\().*(?=\\))"),
        sep = "_")) %>%
  
  # Add id for outcome as single variable
  tidyr::unite("outcome_id",
               outcome_metric, outcome_disease, outcome_group,
               na.rm = TRUE,
               remove = FALSE) %>%
  # Add id for pair as single variable
  tidyr::unite("pair_id",
               pollutant, outcome_id, choice_pair,
               na.rm = TRUE,
               remove = FALSE) %>% 
  # Add id for rr
  tidyr::unite("rr_id",
               pair_id, rr_source_rFormat, choice_rr,
               sep = "_", 
               na.rm =TRUE,
               remove = FALSE) %>%
  # Keep only unique RRs (id, value and CI category) to avoid duplicates
  dplyr::distinct(., rr_id, rr, ci, 
                  .keep_all = TRUE) %>%
  # Change position of some columns
  dplyr::relocate(c(rr_increment, rr_unit), .after=rr) %>%
# Pivot wider to have ci in columns
  tidyr::pivot_wider(values_from = c(rr, rr_original, rr_rescaled), 
                     names_from = ci)

# Store the relevant pollutant-outcomes pairs 

# Pollutant-outcome pairs to be considered in the main analysis or in the appendix
choice_pairs_main <- rr_data %>% 
  dplyr::filter(choice_pair %in% "main") %>% 
  select(pair_id) %>% 
  unique() %>% 
  pull()

choice_pairs_appendix <- rr_data %>% 
  dplyr::filter(choice_pair %in% "appendix") %>%
  select(pair_id) %>% 
  unique() %>% 
  pull()

choice_pairs_all <- c(choice_pairs_main, choice_pairs_appendix)

# RRs to be considered in the main analysis or only as sensitivity analysis
choice_rr_main_selected <- 
  rr_data %>% 
  dplyr::filter(pair_id %in% choice_pairs_main & 
                  choice_rr %in% "selected") %>% 
  select(rr_id) %>% unique() %>% pull()
choice_rr_main_sensitivity <- 
  rr_data %>% 
  dplyr::filter(pair_id %in% choice_pairs_main & 
                  choice_rr %in% "sensitivity") %>% 
  select(rr_id) %>% unique() %>% pull()


choice_pairs <- c("main", "appendix")
choice_rrs <- c("selected", "sensitivity")

# Select RR data for all-cause mortality (removing disease specific)
rr_data_allCauseMortality <-
  dplyr::filter(rr_data,
    outcome_metric %in% "premature deaths" &
    outcome_disease %in% "all causes")

rr_data_morbidities <- 
   dplyr::filter(rr_data,
    !outcome_metric %in% "premature deaths")
```

## Population data 
```{r Edit population data by age for life table}

# Create a list with two elements to split male and female data (for seperate life table calculations)
population_byAge <- 
  list()

for (s in sex){
  population_byAge[[s]] <- 
    population_byAge_rawdata %>%
    # Select relevant columns
    dplyr::select(age, starts_with(s)) %>%
    # Estimate the population at the middle of 2019 by 
    # calculating the average between the population at the end of 2018 and 2019
    dplyr::mutate(
      population = rowMeans(across(contains(s)), na.rm = TRUE)) %>%
    # Remove male and female columns used to calculate the mean
    dplyr::select(-contains(s)) %>%
    # Remove "und mehr" (and more)
    dplyr::mutate(
      age = gsub(" und mehr","", age ))
}

total_population <- 
  sum(
    sum(population_byAge[["male"]]$population),
    sum(population_byAge[["female"]]$population))
```

## Baseline morbidity data

```{r Edit bhd_data}

# Adapt the rawdata as needed
bhd_data <- 
  bhd_rawdata %>%
  dplyr::mutate(
    # Change format of year
    bhd_year = as.character(bhd_year),
    # Calculate the rate based on the absolute value
    # Already available in the csv file but to be overwritten  
    # to update the information.
    bhd_rate = round((bhd_absolute/total_population)*1E5, 2)) %>%
  # Add bhd_id
  tidyr::unite("outcome_id",
               outcome_metric, outcome_disease, outcome_group,
               sep = "_", 
               na.rm =TRUE,
               remove = FALSE) %>%
  # Filter the data to remove "all ages" in some of the GBD data
  dplyr::filter(!(source %in% "IHME (2020)" & 
                    outcome_disease %in% c("lung cancer",
                                           "ischemic heart disease",
                                           "stroke",
                                           "diabetes (type 2)",
                                           "dementia")
                  &  bhd_age %in% "all"))

# Select only morbidity (mortality is to be done with life tables)
bhd_data_morbidity <- bhd_data %>%
  # Filter for relevant rows 
  dplyr::filter(!outcome_metric %in% "premature deaths")
```


## Baseline mortality data

```{r Edit life table}
#TODO: AirQ+ require the death rate by age to derive probability of surviving
# instead of using the probability of dying as here. 
# The AirQ+ method has to be accomodated here. 
# See  formulas here: https://www.who.int/europe/publications/i/item/WHO-EURO-2020-1559-41310-56212

for(s in sex){
  # Life table for 2019
  # Average of the period 2016-2020
  lifetable[[s]] <- lifetable[[s]] %>% 
  # Life table for 2019
  # Average of the period 2016-2020
    # Rename columns
    dplyr::rename("age" = "AGE..X." ,
                  "indicator" = "INDICATOR",
                  "year"  = "PERIOD",
                  "value" = "VALUE") %>%
    # Convert value to numeric
    dplyr::mutate(value = as.numeric(value)) %>%
    # Filter only columns for years within the period 2015 - 2019
    dplyr::filter(year %in% c(2015:2019)) %>%
    # Obtain mean of the period 2016-2020 as value for 2019
    dplyr::group_by(indicator, age) %>%
    dplyr::summarize(mean= mean(value), .groups = "drop") %>%
    # Wider form
    tidyr::pivot_wider(names_from = indicator, values_from = mean) %>%
    # Rename column probability of dying
    dplyr::rename("death_probability" = "Q(X)") %>%
    # Select columns probability of dying (drop the other indicators)
    dplyr::select(age, death_probability) %>% 
    dplyr::mutate(age=as.character(age))
    }

```

```{r Edit non-natural mortality data}

#Create a copy of rawdata to edit them
nonNatural_mortality <- nonNatural_mortality_rawdata 
total_mortality <- total_mortality_rawdata 
# Create list joining non-natural and total mortality data
mortality_data_beforeCorrecting <- list()
mortality_data <- list()

# Calculate average by age in non-natural and total mortality
for(s in sex){
    # Non-natural mortality
    nonNatural_mortality[[s]] <- 
      nonNatural_mortality[[s]] %>%
      # Select columns keeping only those 10 year before (2010-2019)
      dplyr::select(all_of(c("Age", as.character(2010:2019)))) %>%
      # Calculate average by age
      dplyr::mutate(mean_nonNatural = 
                      rowMeans(subset(nonNatural_mortality[[s]], 
                                      select = -Age), 
                               na.rm = TRUE))
    
    # Total mortality
    total_mortality[[s]] <- 
      total_mortality[[s]] %>%
      # Select columns keeping only those 10 year before (2010-2019)
      dplyr::select(all_of(c("Age", as.character(2010:2019)))) %>%
      # Calculate average by age
      dplyr::mutate(mean_total = 
                      rowMeans(subset(total_mortality[[s]], 
                                      select = -Age), 
                               na.rm = TRUE))
 # Joined data set with total and natural mortality together
  mortality_data_beforeCorrecting[[s]] <-
    # Add row from non-natural mortality
    dplyr::left_join(total_mortality[[s]][, c("Age", "mean_total")],
                     nonNatural_mortality[[s]][, c("Age", "mean_nonNatural")],
                     by = "Age") %>%
    dplyr::rename("age" = "Age") %>%
    # Calculate percentage of deaths from non-natural mortality
    dplyr::mutate(percent_nonNatural_raw = mean_nonNatural / mean_total)
    
    
    # Calculate the moving average (mean of 5 ages) to correct yearly deviations
  mortality_data[[s]] <-
    mortality_data_beforeCorrecting[[s]] %>%
    dplyr::mutate(percent_nonNatural_movingAverage = 
                    zoo::rollmean(percent_nonNatural_raw, 
                                  k = 5, 
                                  fill = NA)) %>%
    # The three first lines of the moving average are special cases
    # Edit them manually
    dplyr::mutate(percent_nonNatural = 
                    ifelse(age == 0, percent_nonNatural_raw,
                           ifelse(age == 1, mean(percent_nonNatural_raw[2:4], 
                                                 na.rm =TRUE),
                                  ifelse(age == 2, mean(percent_nonNatural_raw[2:5],
                                                        na.rm =TRUE),
                                         percent_nonNatural_movingAverage)))) %>%
    # Keep only age and percentage of non-natural deaths, which the only data needed.
    dplyr::select(age, percent_nonNatural)
}
```


```{r Join lifetable and population data}

lifetable_withPopulation <- list()

for(s in sex){
  lifetable_withPopulation[[s]] <-
    get_lifetable_withPopulation(
      lifetable = lifetable[[s]],
      population = population_byAge[[s]],
      nonNatural_mortality = mortality_data[[s]],
      year_of_analysis = 2019)

}
```

```{r Create lifetable as in Airq+}

#Create list to derive natural deaths
natural_mortality <- list()

for(s in sex){
  natural_mortality[[s]] <- 

    # Join total and non natural deaths
    dplyr::left_join(
      dplyr::select(total_mortality[[s]], Age,  mean_total),
      dplyr::select(nonNatural_mortality[[s]], Age,  mean_nonNatural),
      by="Age")%>%
    # Rename age
    dplyr::rename(age = Age) %>%
    # Delete total row
    dplyr::filter(!age %in% "Total") %>%
    # Replace NA with 0
    dplyr::mutate(mean_nonNatural = 
                    ifelse(is.na(mean_nonNatural), 0, mean_nonNatural)) %>%
    # Calculate difference between total and non natural
    dplyr::mutate(natural_deaths = round(mean_total-mean_nonNatural, 0)) %>%
    # Select only relevant columns
    dplyr::select(age, natural_deaths)
  
}

natural_mortality <- 
  dplyr::left_join(natural_mortality[["male"]],
                   natural_mortality[["female"]],
                   by = "age",
                   suffix = c("_male", "_female"))

# Population data in life table  
lifetable_airqplus <- 
  # Convert list into data frame
  dplyr::left_join(population_byAge[["male"]], 
                   population_byAge[["female"]],
                   by = "age",
                   suffix = c("_male", "_female")) %>%
  # Round population values
  dplyr::mutate(population_male =round(population_male, 0),
                population_female = round(population_female, 0)) %>%
  # Add mortality data
  dplyr::left_join(.,
                   natural_mortality,
                   by = "age") %>%
  # Convert age to numeric (previously character)
  dplyr::mutate(age = as.numeric(age)) %>%
  # Duplicate column for age as in AirQ+
  dplyr::mutate(age_end = age, .after = age)
```

## Concentration data

```{r exposure data scenario}

# Select relevant columns
# This data set will include other data beyond those from HRAs
exp_data <- 
  exp_rawdata %>%
  # Remove not relevant columns
  dplyr::select(-url, -hra, -estimation) %>%
  # Remove the columns for lower and upper bound of the concentration 
  # (not relevant but maybe later)
  dplyr::select(-exp_lower, -exp_upper) %>%
  # Rename concentration column
  #dplyr::rename(exp = exp_mean) %>%
  # Add columns with the original values (before re-scaling)
  dplyr::mutate(
    pollutant_original = pollutant,
    exp_original = exp_central,
    # Modify columns pollutant
    pollutant = 
      ifelse(pollutant %in% pm_no_target, 
             pm_target, 
             pollutant_original)) %>%
  # Convert the exposure
  dplyr::mutate(
    exp = 
      rescale_conc_pmFraction(
        conc = exp_original,
        pm_original = pollutant_original,
        pm_target = pm_target))
```

```{r Subsets exposure data scenario}

# Exposure data in a list form
exp_data_forLoop <- 
  exp_data %>%
  # Split (make list) by pollutant and year
  split(.$pollutant)%>%
  purrr::map(function(x) split(x, x$year))
```

```{r cutoff scenario}

cutoff_data <-
  cutoff_rawdata %>%
  # Take the relevant columns and rows 
  dplyr::filter(pollutant %in% c("PM2.5", "NO2")) %>%
  dplyr::select(pollutant, cutoff_central, cutoff_unit) %>%
  # Rename cutoff_mean to cutoff 
  # TODO: to be changed if we used cutoff with CI
  dplyr::rename(cutoff = cutoff_central)
  
```

# Social aspects
```{r Input data and results for social aspects (deprivation index)}
## subset Flanders (NUTS1 = BE2)
social_mort_data <- 
  dplyr::filter(
  social_mort_rawdata,
  NUTS1 == 'BE2' & POPULATION > 0)

# Join input data tables
social_data <-
  dplyr::left_join(
    x = social_mort_data,
    y= social_bimd_rawdata,
    by = c("CS01012020" = "CD_RES_SECTOR")) 

# Data set to be used as input in the R package
social_data_input <-
  social_data |>
  # Remove the columns rank and deciles (to be done by the R package)
  dplyr::select(-rank, -deciles)
  
```

```{r social results}
## exposure and attributable burden per deprivation decile
social_per_decile <- 
  data.frame(
    exposure_mean = with(social_data, tapply(PM25_MEAN, deciles, mean)),
    mort_attr = 1e5 * with(social_data, tapply(MORTALITY_ATTR, deciles, sum))/
      with(social_data, tapply(POPULATION, deciles, sum)),
    mort_total = 1e5 * with(social_data, tapply(MORTALITY_TOTAL, deciles, sum))/
      with(social_data, tapply(POPULATION, deciles, sum)))


## inequalities

social_results <- 
  data.frame(
    exp_abs_diff = social_per_decile[["exposure_mean"]][1] - social_per_decile[["exposure_mean"]][10], ## absolute diff,
    exp_rel_diff = 100 * ( (social_per_decile[["exposure_mean"]][1] / social_per_decile[["exposure_mean"]][10]) - 1 ), ## relative diff
    exp_paf_di = 100 * (mean(social_data$PM25_MEAN) - social_per_decile[["exposure_mean"]][10]) / mean(social_data$PM25_MEAN), # PAF
    mort_abs_diff = social_per_decile[["mort_attr"]][1] - social_per_decile[["mort_attr"]][10], ## absolute diff
    mort_rel_diff = 100 * ( (social_per_decile[["mort_attr"]][1] / social_per_decile[["mort_attr"]][10]) - 1 ), ## relative diff
    mort_mean = (1e5 * sum(social_data$MORTALITY_ATTR) / sum(social_data$POPULATION))) |>
  dplyr::mutate(
    mort_paf_di = 100 * (mort_mean - social_per_decile[["mort_attr"]][10]) / mort_mean # PAF
  )
```



# Misc
```{r Create Codebook}
# Do not forget yll
codebook <- unique(bhd_data[, c("outcome_id", "mort_morb")]) 

#TODO: Here a table with the correspondence between 
# short names or ids (without spaces) 
# and labels (spaces and eventually capital letter)
# should be built
```

```{r prepare input data for function}
input_data <-
  # Join data sets of input data: exposure data, bhd data, counterfactual data
  dplyr::left_join(exp_data, rr_data, by="pollutant", 
                   suffix =c("_exp", "_rr"),
                   relationship = "many-to-many") %>%
  dplyr::left_join(., bhd_data, by="outcome_id",
                   suffix = c("", "_bhd"),
                   relationship = "many-to-many") %>%
  dplyr::left_join(., cutoff_data, by="pollutant",
                   relationship = "many-to-one")%>%
  # Add the minimum age and maximum age for each row 
  # (only relevant for mortality with lifetable)
  dplyr::mutate(
    min_age = ifelse(
      mort_morb %in% "mortality" & outcome_group_bhd %in% "adults", 
      20,
      NA),
    max_age = ifelse(
      mort_morb %in% "mortality" & outcome_group_bhd %in% "infants",
      0,
      NA))

input_data_morbidities <- 
  input_data %>%
  dplyr::filter(rr_id %in% rr_data_morbidities$rr_id)

input_data_mortality <- 
  input_data %>%
  dplyr::filter(rr_id %in% rr_data_allCauseMortality$rr_id)
```



```{r Export environment}
# Keep only variables/functions that will be used in "testing_Rpackage.Rmd"
rm(list=setdiff(ls(), 
                c(# Data
                  "airqplus_pm_copd",
                  "airqplus_deaths_pop_multipleYear",
                  "airqplus_deaths_pop_singleYear",
                  "airqplus_pm_deaths_yll",
                  "niph_noise_ha_excel",
                  "niph_noise_hsd_excel", 
                  "niph_noise_ihd_excel",
                  "codebook",
                  "input_data_morbidities",
                  "input_data_mortality",
                  "lifetable_airqplus",
                  "lifetable_withPopulation",
                  "rr_data",
                  # Values (keep none)
                  # Functions
                  "paste_round_CI",
                  "round_keeping0",
                  "check_bestcost",
                  "runif_with_seed",
                  "social_data",
                  "social_per_decile", 
                  "social_results"
                  )))
# save.image(file = "../testing/input/data/input_data_for_testing_Rpackage.RData")
```

