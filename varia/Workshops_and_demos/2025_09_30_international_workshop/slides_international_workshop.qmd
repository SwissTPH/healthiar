---
title: "Hello, I'm healthiar!"
# subtitle: "Comparison of methods"
author:
  - name:
      given: Axel Luyten and
      family: Alberto Castro
    # affiliations:
      # - name: Swiss TPH
    # orcid: 0000-0002-7005-5889
    email: axel.luyten@swisstph.ch & alberto.castrofernandez@swisstph.ch
date: 2025-09-30 # last-modified
editor: source
execute: 
  eval: true
  echo: true
  warning: false
freeze: auto
format:
  revealjs:
    # code-line-numbers: true # Doesn't work; probably works for html format
    css: custom_style.css
    # code-tools: # Test at later point what this does
      # source: https://github.com/best-cost/best-cost_WPs/tree/master
    # code-fold: true # Folds code chunk in the HTML prez
    incremental: true
    transition: none # alts: fade, none, slide
    transition-speed: default
    # table-of-contents: true
    # toc-depth: 1
    logo: images/combo_logo_stph_bc.png
    # footer: 'healthiar WP5 workshop 1'
    smaller: true # If you set {.smaller} after the slide title, reduces font automatically so content fits on slide
    scrollable: true # If you set {.scrollable} after the slide title, let's you scroll on the slide
    template-partials:
      - title-slide.html
    title-slide-attributes:
      data-background-image: images/combo_title_stph_bc.png
      data-background-size: contain
      data-background-opacity: "1"
    slide-number: true
    embed-resources: true
---

<!-- #TODO -->

<!-- add example of sub-group analysis with info argument  -->

<!-- show detailed attribute health results just before summarize_uncertainty -->

# Today

```{r, echo=FALSE, include=TRUE}
library(healthiar)
library(tibble)
library(dplyr)
library(purrr)
library(tidyr)
library(knitr)

options(knitr.kable.max_rows = 100)
set.seed(1)
```

:::: {.columns}

::: {.fragment .column width="50%"}
**First hour**

-   Hello, I'm `healthiar`!

-   `healthiar` function examples

-   Outlook

-   Q & A

::: fragment
**Break**
:::
:::

::: {.fragment .column width="50%"}
**Second hour**

-   Hands-on mock case studies

-   Q & A
:::
::::

# Hello, I'm `healthiar`!

## `healthiar` overview

`healthiar` is a R package (= collection of R functions) to quantify and monetize the burden of disease attributable to exposures

![DALY = disability-adjusted life years; YLD = years lived with disability; YLL = years of life lost](images/package_overview.png){width="1750" fig-align="left"}

# Example: `attribute_health()` with RR

------------------------------------------------------------------------

## Refresher - Burden of disease with relative risk

![](images/bod_rr.png){fig-align="left"}

## `attribute_health()` with RR 1/3

Goal: attribute COPD cases to PM2.5 air pollution exposure

<!-- Introduce here R lingo  -->
::::: fragment
:::: panel-tabset
## Hard-coded input data

```{r, eval=TRUE,include=TRUE,echo=TRUE}
#| code-line-numbers: "|1|2-4|5|6|7|"

results_pm_copd <- attribute_health(
  erf_shape = "log_linear", # erf = exposure-response function
  rr_central = 1.369, 
  rr_increment = 10,  # μg / m^3
  exp_central = 8.85, # μg / m^3
  cutoff_central = 5, # μg / m^3
  bhd_central = 30747 # bhd = baseline health data (here: COPD incidence)
) 
```

## Pre-loaded data

::: callout-tip
`healthiar` comes with some example data that start with `exdat_` that allow you to test functions.
:::

```{r, eval=TRUE,include=TRUE,echo=TRUE}

results_pm_copd <- attribute_health(
  erf_shape = "log_linear",
  rr_central = exdat_pm$relative_risk, 
  rr_lower = exdat_pm$relative_risk_lower,
  rr_upper = exdat_pm$relative_risk_upper,
  rr_increment = 10, 
  exp_central = exdat_pm$mean_concentration,
  cutoff_central = exdat_pm$cut_off_value,
  bhd_central = exdat_pm$incidence
) 
```
::::
:::::

## `attribute_health()` with RR 2/3


`attribute_health()` outputs two lists ("folders")

-   `health_main` contains the main results

-   `health_detailed` contains more detailed results and other assessment details in sub-lists ("sub-folders")

:::: fragment
::: callout-tip
Other `healthiar` functions also create `..._main` & `..._detailed` folders
:::
::::

:::: fragment
::: panel-tabset

## With `$` operator

```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_pm_copd$health_main
```
## By clicking

Go to the *Environment* tab in RStudio ...

![](images/rstudio_env.png){fig-align="left"}

... and click on a variable to "open" it.

Alternatively, you can use `View(results_noise_ha)`, which has the same effect.
:::
::::

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_pm_copd[["health_main"]] |> 
  dplyr::select(impact_rounded, impact, pop_fraction, erf_ci, rr, exp, bhd) |> 
  dplyr::slice(1) |> 
  knitr::kable()
```
:::
:::

## `attribute_health()` with RR 3/3

::: fragment
If we add 95% confidence intervals to `attribute_health()` ...
:::

::: fragment
```{r, eval=TRUE,include=TRUE,echo=TRUE}
#| code-line-numbers: "|3,5,7|"

results_pm_copd <- attribute_health(
  erf_shape = "log_linear",
  rr_central = 1.369, rr_lower = 1.114, rr_upper = 1.664,
  rr_increment = 10,
  exp_central = 8.85, exp_lower = 8, exp_upper = 10,
  cutoff_central = 5,
  bhd_central = 30747, bhd_lower = 28000, bhd_upper = 32000
) 
```
:::

::: fragment
... then the folder `health_detailed` contains all different uncertainty combinations:
:::

::: fragment
```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_pm_copd$health_detailed$results_raw
```
:::

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_pm_copd[["health_detailed"]][["results_raw"]] |> 
  dplyr::select(erf_ci, exp_ci, bhd_ci, impact_rounded, rr, exp, bhd) |> 
  knitr::kable()
```
:::
:::

## `attribute_health()` with RR and user-defined ERF 1/2

Goal: attribute COPD cases to air pollution exposure by applying a user-defined exposure response function (e.g. MR-BRT curves from Global Burden of Disease study)

-   Any function of the form *intercept + a x c\^1 + b x c\^2 + ...*

-   Any other (non-linear) function of the `function` type, as obtained from e.g. `splinefun()` or `approxfun()`

::: fragment
```{r echo=TRUE,eval=TRUE,include=TRUE}
#| code-line-numbers: "|4-7|"

results_pm_copd_mr_brt <- attribute_health(
  exp_central = 8.85,
  bhd_central = 30747,
  erf_eq_central = splinefun(
    x = c(0, 5, 10, 15, 20, 25, 30, 50, 70, 90, 110),
    y = c(1.00, 1.04, 1.08, 1.12, 1.16, 1.20, 1.23, 1.35, 1.45, 1.53, 1.60),
    method = "natural")
)
```
:::

## `attribute_health()` with RR and user-defined ERF 2/2

::: {.absolute left=0}
```{r, echo=FALSE, eval=TRUE, include=TRUE}

x <- c(0, 5, 10, 15, 20, 25, 30, 50, 70, 90, 110)
y <- c(1.00, 1.04, 1.08, 1.12, 1.16, 1.20, 1.23, 1.35, 1.45, 1.53, 1.60)

spline_func <- 
  stats::splinefun(
    x = x,
    y = y,
    method = "natural")

# Generate finer x-values
x_dense <- seq(min(x), max(x), length.out = 200)

# Evaluate the spline function at these points
y_dense <- spline_func(x_dense)

# Plot
plot(x, 
     y, 
     # main = "User-defined ERF", 
     main = "", 
     xlab = "Exposure",
     ylab = "Relative risk",
     col = "blue", 
     pch = 19)
lines(x_dense, y_dense, col = "red", lwd = 2)
legend("topleft", legend = c("Original points", "Spline curve"),
       col = c("blue", "red"), pch = c(19, NA), lty = c(NA, 1), lwd = c(NA, 2))
```
:::

# Example: `attribute_health()` with AR

## Refresher - Burden of disease with absolute risk

![](images/bod_ar.png){fig-align="left"}

## `attribute_health()` with AR 1/2

Goal: attribute cases of high annoyance (HA) to noise exposure

::: fragment
::: {.absolute left=0}
| Exposure category | Exposure mean | Population exposed |
|-------------------|---------------|--------------------|
| exp < 55          |               | 4'268'785          |
| 55 ≤ exp < 60     | 57.5          | 387'500            |
| 60 ≤ exp < 65     | 62.5          | 286'000            |
| 65 ≤ exp < 70     | 67.5          | 191'800            |
| 70 ≤ exp < 75     | 72.5          | 72'200             |
| 75 ≤ exp          | 77.5          | 7'700              |
:::
:::

<div style="height: 350px;"></div>

::: fragment
```{r}
#| code-line-numbers: "|2|3|4-5|"
results_noise_ha <- attribute_health(
  approach_risk = "absolute_risk",
  erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
  exp_central = c(57.5, 62.5, 67.5, 72.5, 77.5),
  pop_exp = c(387500, 286000, 191800, 72200, 7700),
)
```
:::

## `attribute_health()` with AR 2/2

::: fragment
```{r, echo=TRUE, eval=FALSE, include=TRUE}
results_noise_ha$health_main
```
:::


::: fragment
::: {.absolute left=0}
```{r, echo=FALSE, eval=TRUE, include=TRUE}
results_noise_ha[["health_main"]] |> 
  select(approach_risk, exp_category, impact) |> 
  knitr::kable()
```
:::
:::

<div style="height: 120px;"></div>

::: fragment
```{r, echo=TRUE, eval=FALSE, include=TRUE}
results_noise_ha$health_detailed$results_raw
```
:::

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE, eval=TRUE, include=TRUE}
results_noise_ha[["health_detailed"]][["results_raw"]] |> 
  select(exp_category, exp, pop_exp, impact) |> 
  knitr::kable()
```
:::
:::

# Example: `attribute_health()` across multiple geographic units

## `attribute_health()` across multiple geographic units 1/3

Goal: attribute disease cases to PM2.5 exposure in multiple geographic units, such as municipalities, provinces, countries, ...


::: fragment
```{r}
#| code-line-numbers: "|2-3|8-9|"

results_iteration <- attribute_health(
  geo_id_micro = c("Zürich", "Basel", "Geneva", "Ticino", "Jura"), 
  geo_id_macro = c("German","German","French","Italian","French"),
  erf_shape = "log_linear",
  rr_central = 1.369,
  rr_increment = 10, 
  cutoff_central = 5,
  exp_central = c(11, 11, 10, 8, 7),
  bhd_central = c(4000, 2500, 3000, 1500, 500)
)
```
:::

::: fragment
Here the we want to aggregate results by language region (`"German", "French", "Italian"`)
:::

## `attribute_health()` across multiple geographic units 2/3

::: fragment
```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_iteration$health_main
```
:::

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_iteration[["health_main"]] |> 
  dplyr::select(geo_id_macro, impact_rounded, erf_ci, exp_ci, bhd_ci) |> 
  knitr::kable()
```
:::
:::

<div style="height: 240px;"></div>

:::: fragment
::: callout-tip
The main output contains aggregated results if available, or disaggregated results if no aggregation ID was provided
:::
::::

## `attribute_health()` across multiple geographic units 3/3

::: fragment
```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_iteration$health_detailed$results_raw
```
:::

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_iteration[["health_detailed"]][["results_raw"]] |> 
  select(geo_id_micro, geo_id_macro, impact_rounded) |> 
  knitr::kable()
```
:::
:::


# <span style="font-size: 0.8em;">Example: `summarize_uncertainty()`</span>

## `summarize_uncertainty()` 1/3

Goal: perform a Monte Carlo simulation to obtain summary uncertainty confidence intervals that combine uncertainty in different input data


::::: columns
::: {.column .fragment width="45%"}
Step 1: Use `attribute_health()` with uncertainty in ≥ 2 function arguments

```{r, eval=TRUE,include=TRUE,echo=TRUE}
#| code-line-numbers: "|4-5,8-9,12-13|"

results <- 
  attribute_health(
    erf_shape = "log_linear",
    rr_central = 1.369, 
    rr_lower = 1.114, 
    rr_upper = 1.664,
    rr_increment = 10,
    exp_central = 8.85, 
    exp_lower = 8, 
    exp_upper = 10,
    cutoff_central = 5,
    bhd_central = 30747, 
    bhd_lower = 28000, 
    bhd_upper = 32000) 
```
:::

::: {.column .fragment width="45%"}
Step 2: `summarize_uncertainty()` to obtain the confidence intervals

```{r, eval=TRUE,include=TRUE,echo=TRUE}
results <- 
  summarize_uncertainty(
    output_attribute = results,
    n_sim = 100
  )
```
:::
:::::

## `summarize_uncertainty()` 2/3

```{r, echo=TRUE,eval=FALSE,include=TRUE}
results$uncertainty_main
```

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results$uncertainty_main |> 
  dplyr::select(-geo_id_micro) |>
  knitr::kable()
```
:::
:::

## `summarize_uncertainty()` 3/3

```{r, echo=TRUE,eval=FALSE,include=TRUE}
results$uncertainty_detailed$attribute_by_sim_disaggregated
```

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results$uncertainty_detailed$attribute_by_sim_disaggregated |> 
  dplyr::select(-geo_id_micro, -input, -output) |> 
  dplyr::relocate(impact, .after = sim_id) |>
  knitr::kable()
```
:::
:::

# Example: `compare()` two scenarios

## `compare()` 1/2

Goal: compare attributable health impacts in two (policy) scenarios

::: {.fragment .nonincremental}
1.  Use `attribute_health()` to calculate burden of scenarios 1 & 2
:::

::::: columns
::: {.column .fragment width="50%"}
```{r}
#| code-line-numbers: "|5"

scenario_1 <- attribute_health(
  erf_shape = "log_linear",
  rr_central = 1.118,
  rr_increment = 10,  
  exp_central = 8.85, # EXPOSURE 1
  bhd_central = 25000
)
```
:::

::: {.column .fragment width="50%"}
```{r}
#| code-line-numbers: "|5"

scenario_2 <- attribute_health(
  erf_shape = "log_linear",
  rr_central = 1.118,
  rr_increment = 10,
  exp_central = 6, # EXPOSURE 2
  bhd_central = 25000
)
```
:::
:::::

::: {.fragment .nonincremental}
2.  Use `compare()` to compare scenarios 1 & 2
:::

::: fragment
```{r}
results_comparison <- compare(
  output_attribute_scen_1 = scenario_1,
  output_attribute_scen_2 = scenario_2,
  approach_comparison = "delta" # or "pif" (population impact fraction)
)
```
:::

## `compare()` 2/2

```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_comparison$health_main
```

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_comparison[["health_main"]] |> 
  dplyr::select(
    impact, impact_rounded,
    impact_scen_1, impact_scen_2,
    bhd,
    dplyr::starts_with("exp_"),
    -dplyr::starts_with("exp_ci"), # remove col "exp_ci"
    dplyr::starts_with("rr_con")) |> 
  dplyr::slice_head() |> 
  knitr::kable()
```
:::
:::

# Other `healthiar` functions

## Other `healthiar` functions

<!--  Additional existing `healthiar` functions -->

-   `attribute_lifetable()` for YLL
-   `attribute_health()` for YLD (using the `dw` & `duration` arguments)
-   `get_daly()` as the sum of YLL and YLD
-   `monetize()` monetizes (attributable) health impacts
-   `cba()` performs a cost-benefit analysis (CBA)
-   `multiexpose()` considers exposure to 2 exposures (e.g. two different air pollutants) at the same time to quantify the attributable health impacts
-   `prepare_exposure()` calculates (population-weighted) mean exposure by combining spatial exposure geographic units data 
-   `socialize()` determines burden attributable to differences in a social indicator
-   `attribute_mod()` modifies an existing `attribute_health()` assessment
-   `prepare_mdi()` creates the BEST-COST MDI (Multidimensional Deprivation Index)


# Outlook

## Outlook
<!-- TODO add link to GitHub page -->
-   `healthiar` is publicly available on this GitHub page
    -   `healthiar` might be expanded in the future (if funding available)
-   Python version coming out later in 2026
-   Package submitted to CRAN


# Q & A

# Happy coding! : )

# Appendix

# Example: `monetize()` health impacts

## `monetize()` 1/2

Goal: monetize (attributable) health impacts (obtained from `healthiar` or other source)

-   *Discounting* yes/no
-   *Inflation* yes/no

::: fragment

```{r, echo=FALSE}
results_pm_copd <- attribute_health(
  erf_shape = "log_linear", # Alternatives: "linear", ...
  rr_central = 1.369, 
  rr_lower = 1.114, 
  rr_upper = 1.664,
  rr_increment = 10,  # μg / m^3
  exp_central = 8.85, # μg / m^3
  cutoff_central = 5, # μg / m^3
  bhd_central = 30747 # baseline health data: COPD incidence
) 
```

```{r}
results_monetization <- monetize(
  output_attribute = results_pm_copd,
  valuation = 20,
  discount_shape = "exponential",
  discount_rate = 0.03,
  discount_years = 5
)
```
:::

::: fragment
::: callout-tip
`monetize()` can also monetize impacts from a non-`healthiar` source
:::
:::

## `monetize()` 2/2

::: fragment
```{r, echo=TRUE,eval=FALSE,include=TRUE}
results_monetization$monetization_main
```
:::

::: fragment
::: {.absolute left=0}
```{r, echo=FALSE,include=TRUE,eval=TRUE}
results_monetization[["monetization_main"]] |> 
  dplyr::select(
    impact, monetized_impact, discount_rate, valuation, 
    monetized_impact_before_inflation_and_discount, 
    monetized_impact_after_inflation_and_discount) |> 
  dplyr::slice_head() |> 
  knitr::kable()
```
:::
:::

# More info

## `healthiar` in RStudio 1/3

![Figure: Landing page of the `healthiar` package in RStudio, where you find the package vignettes and function documentation.](images/healthiar_package_landing_page.png){width="1000" fig-align="left"}

## `healthiar` in RStudio 2/3

![Figure: Intro to `healthiar` vignette (= detailed guide to the package)](images/vignette_start.png){width="700" fig-align="left"}

## `healthiar` in RStudio 3/3

![Figure: Help page of `attribute_health()`](images/fun_doc_start.png){width="900" fig-align="left"}


## Export results

::: panel-tabset
## Export as `.csv` file

```{r, eval=FALSE,echo=TRUE,include=TRUE}
write.csv(x = results_pm_copd$health_main, file = "exported_results/results_pm_copd.csv")
```

## Save as `.Rdata` file

```{r, eval=FALSE,echo=TRUE,include=TRUE}
save(results_pm_copd, file = "exported_results/results_pm_copd.Rdata")
```

## Export to Excel (as `.xlsx` file)

```{r, eval=FALSE,echo=TRUE,include=TRUE}
write.xlsx(x = results_pm_copd$health_main, file = "exported_results/results_pm_copd.xlsx")
```

![*Exported to .xlsx format*](images/export_xlsx.png){fig-align="left"}
:::

## Visualize results

::: nonincremental
Visualization is out of scope of `healthiar`. You can visualize in

-   R, e.g. with the `ggplot2` package ([online book by the creator](https://ggplot2-book.org/))
-   Excel (export results first)
-   Other tools
:::

--------------------------------------------------------------------------------
